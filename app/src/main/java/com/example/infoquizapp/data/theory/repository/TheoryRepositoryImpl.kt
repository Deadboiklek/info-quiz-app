package com.example.infoquizapp.data.theory.repository

import android.text.Html
import androidx.compose.ui.res.painterResource
import com.example.infoquizapp.R
import com.example.infoquizapp.data.TheoryDao
import com.example.infoquizapp.data.theory.TheoryEntity
import com.example.infoquizapp.domain.theory.repository.TheoryRepository
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class TheoryRepositoryImpl(private val theoryDao: TheoryDao) : TheoryRepository {
    override suspend fun getTheory(id: Int): TheoryEntity? {
        return theoryDao.getTheoryById(id)
    }

    override suspend fun markTheoryAsRead(id: Int) {
        theoryDao.updateReadStatus(id, true)
    }

    override suspend fun getAllTheory(): List<TheoryEntity> {
        return theoryDao.getAllTheory()
    }

    init {
        CoroutineScope(Dispatchers.IO).launch {
            if (theoryDao.getTheoryCount() == 0) {
                val initialData = listOf(
                    TheoryEntity(
                        title = "Задание 1",
                        image = null,
                        content = """
    **1. Основные понятия**
    
    1. Бит — минимальная единица информации (0 или 1).
    2. Байт = 8 бит.
    3. **Кодировка символов** — способ представления текста в компьютере:
       - **8-битная** (1 байт на символ) → ASCII, КОИ-8 (латиница, кириллица, цифры).
       - **16-битная** (2 байта на символ) → Unicode (UTF-16, поддерживает кириллицу, иероглифы).
       - **32-битная** (4 байта на символ) → UTF-32 (редко, для спецсимволов).
    4. **Формулы:**
       - Объём текста (в битах) = кол-во символов × бит на символ.
       - Перевод в байты: биты ÷ 8.
       - Перевод в КБ: байты ÷ 1024.

    **2. Типы задач и примеры решений**

    **1. Задачи на удаление слова из текста**
    
    **Алгоритм решения:**
    1. Определить, сколько байт занимает вычеркнутое слово.
    2. Учесть удаление лишних запятых и пробелов (обычно 2 символа).
    3. Составить уравнение на основе изменения размера текста.

    **Пример 1 (8-битная кодировка):**
    
    В кодировке КОИ-8 каждый символ кодируется 8 битами. 
    Межпланетный спутник передал сообщение: «Обь, Лена, Волга, Москва, Макензи, Амазонка — реки». 
    После удаления названия одной реки переданный объём данных уменьшился на 8 байт. 
    Какое слово было стерто из переданного списка планетарных водоёмов?

    **Решение:**
    1. Размер уменьшился на 8 байт = 64 бита (1 байт = 8 бит).
    2. При удалении слова также удаляются 2 символа (запятая и пробел).
       - Их размер: 2 × 8 бит = 16 бит.
    3. Пусть длина вычеркнутого слова = L. Тогда:
       - L × 8 (бит) + 16 (бит) = 64 (бит)
       - L = (64-16)/8 = 6 символов
    4. Ищем слово из 6 букв: **Москва**.
    
    **Ответ:** Москва.

    **Пример 2 (16-битная кодировка):**
    
     В Unicode каждый символ кодируется 16 битами. 
     Передача с биосферной станции: «Ель, кедр, сосна, кипарис, лиственница, можжевельник — хвойные растения». 
     Объём сигнала уменьшился на 26 байт. Какое межпланетное растение было удалено из сообщения?

    **Решение:**
    1. Размер уменьшился на 26 байт = 208 бит.
    2. Удалено 2 символа: 2 × 16 бит = 32 бита.
    3. Уравнение:
       - L × 16 + 32 = 208
       - L = (208-32)/16 = 11 символов
    4. Ищем слово из 11 букв: **лиственница**.
    
    **Ответ:** лиственница.

    **Пример 3 (32-битная кодировка):**
    
    В UTF-32 каждый символ кодируется 32 битами. 
    Сигнал из фруктового сектора: «Айва, Алыча, Генипа, Гуарана, Курбарил, Мангостан — фрукты». 
    После удаления одного названия передача уменьшилась на 36 байт. 
    Какой межгалактический фрукт исчез из базы данных?

    **Решение:**
    1. Размер уменьшился на 36 байт = 288 бит.
    2. Удалено 2 символа: 2 × 32 бит = 64 бита.
    3. Уравнение:
       - L × 32 + 64 = 288
       - L = (288-64)/32 = 7 символов
    4. Ищем слово из 7 букв: **Гуарана**.
    
    **Ответ:** Гуарана.

    **2. Задачи на расчёт объёма статьи**

    **Пример:**
    
    Бортовая энциклопедия Галактической академии содержит 30 космостраниц, на каждой странице 60 инфострок, в каждой строке 52 символа. 
    Символы кодируются в Unicode (2 байта на символ). 
    Каков общий объём энциклопедии в Кбайтах?

    **Решение:**
    1. Общее количество символов:
       - 30 стр. × 60 строк × 52 символа = 93600 символов
    2. Объём в байтах:
       - 93600 × 2 байта = 187200 байт
    3. Переводим в КБ:
       - 187200 ÷ 1024 = 182,8 КБ
    4. Округляем до целых, так как в ОГЭ обычно требуется точный ответ.

    **Ответ:** 183 КБ.

    **Важно:**
    - Внимательно читайте условие (может быть указано "без лишних пробелов").
    - Проверяйте единицы измерения (биты, байты, КБ).
""".trimIndent(),
                        isRead = false
                    ),
                    TheoryEntity(
                        title = "Задание 2",
                        image = null,
                        content = """ 
# Тема: Анализ и декодирование информации (шифры, кодирование, однозначность расшифровки)

## 1. Шифрование букв номерами в алфавите
**Суть задачи:**
- Каждой букве русского алфавита присваивается номер (например, А=1, Б=2, ..., Я=33).
- Шифровка представляет собой последовательность цифр, которую можно разбить на номера букв разными способами.
- Нужно найти шифровку, которая расшифровывается **единственным способом**.

**Особенности:**
- Номера букв могут быть однозначными (1-9) или двузначными (10-33).
- Неоднозначность возникает, если последовательность цифр можно разбить на номера букв несколькими способами.
- **Ключевой признак единственности:**
  - Все числа в возможных разбиениях должны принадлежать диапазону 1-33.
  - Если при разбиении получается число >33, такой вариант недопустим.

---

**Пример:**  
К вам на базу поступили следующие межзвёздные сигналы:
1. 3102030  
2. 3102033  
3. 3112030  
4. 3112233  

Каждая цифра или пара цифр соответствует буквам галактического алфавита с номерами от 1 до 33. 
В сообщении не может быть "0", так как это пустой код. 
Только один из этих шифров может быть расшифрован единственным способом. Определите его.

**Решение:**  
1. **Шифровка 3102030:**  
   - Варианты разбиения:  
     - `3-1-0-2-0-3-0` → 0 недопустим.  
     - `3-10-20-30` → **ВИТЬ** (В=3, И=10, Т=20, Ь=30).  
     - `31-0-20-30` → 0 недопустим.  
   - **Единственный корректный вариант:** ВИТЬ.

2. **Шифровка 3102033:**  
   - Варианты:  
     - `3-10-20-33` → **ВИТЯ**.  
     - `3-10-20-3-3` → **ВИТВВ**.  
   - **Неоднозначно** → не подходит.

3. **Шифровка 3112030:**  
   - Варианты:  
     - `3-1-1-20-30` → ВААТЬ.  
     - `3-11-20-30` → ВЙТЬ.  
     - `31-1-20-30` → ЭАТЬ.  
   - **Неоднозначно** → не подходит.

4. **Шифровка 3112233:**  
   - Варианты:  
     - `3-1-1-22-33` → ВААФЯ.  
     - `31-12-23-3` → ЭКХВ.  
   - **Неоднозначно** → не подходит.

**Ответ:** Шифровка 3102030 (ВИТЬ).

---

## 2. Шифрование с использованием кодовых таблиц
**Суть задачи:**  
- Буквы заменяются комбинациями символов (например, @, ~, +, !, ?, *, -, •, #, ^, ${'$'}).  
- Каждая буква имеет уникальный код.  
- Нужно определить длину сообщения, зная, что буквы не повторяются.  

**Особенности:**  
- Коды могут быть разной длины.  
- Необходимо сопоставить каждую часть шифра с буквой из таблицы, учитывая, что коды не пересекаются.  

---

**Пример:**  
Фрагмент кодовой таблицы:  
- К: @ +  
- Л: ~ +  
- М: + @  
- Н: @ ~ +  
- О: +  
- П: ~  

Сообщение: `+ ~ + ~ + @ @ ~ +`. Определите количество букв, если они не повторяются.  

**Решение:**  
1. **Разбиваем сообщение на коды:**  
   - Последовательность: `+`, `~`, `+`, `~`, `+`, `@`, `@`, `~`, `+`.  
   - Возможные коды:  
     - `+` → О  
     - `~` → П  
     - `@+` → К  
     - `~+` → Л  
     - `+@` → М  
     - `@~+` → Н  

2. **Анализ разбиения:**  
   - `+` → **О**  
   - `~` → **П**  
   - `+@` → **М** (т.к. повторение О недопустимо)  
   - `@~+` → **Н**  
   - Остается `+` → **О** (повторение, исключаем).  

3. **Итоговое разбиение:**  
   - `+` → О  
   - `~` → П  
   - `+@` → М  
   - `@~+` → Н  
   - `~+` → Л  

**Ответ:** 5 букв (О, П, М, Н, Л).

---

## 3. Другие возможные типы задач
- **Шифр Цезаря** (сдвиг букв на определённое число позиций).  
  *Пример:* А → Б, Б → В и т. д.  
- **Двоичное кодирование** (буквы заменяются на двоичные коды фиксированной длины).  
- **Кодирование с использованием условий** (например, буква кодируется её позицией в слове).  

---

## Итог
1. **Для шифров с номерами букв:**  
   - Проверяйте все возможные разбиения.  
   - Отбрасывайте варианты с числами >33 или 0.  

2. **Для кодовых таблиц:**  
   - Сначала ищите самые длинные коды.  
   - Учитывайте условия (например, неповторяющиеся буквы).  

3. **Советы:**  
   - Начинайте с очевидных кодов.  
   - Проверяйте все возможные комбинации.  
   - Если ответ неочевиден, перебирайте варианты шаг за шагом.  
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 3",
                        image = null,
                        content = """ 
# Тема: Работа с переменными, логическими выражениями и числовыми условиями

## Логические операции
| Операция       | Обозначение | Как работает                              | Пример           |
|----------------|-------------|-------------------------------------------|------------------|
| НЕ             | `not A`     | Инвертирует значение A                    | `not (X > 10)`   |
| И              | `A and B`   | Истина, если обе части истинны            | `X > 5 and X < 20` |
| ИЛИ            | `A or B`    | Истина, если хотя бы одна часть истина    | `X % 2 == 0 or X % 3 == 0` |
| Импликация     | `A → B`     | Истина, если из A следует B               | `X < 5 → X < 10` |
| Эквивалентность| `A == B`    | Истина, если A и B равны                  | `X % 2 == 0 == (X чётное)` |
| Неравенства    | `x > 10`    | Проверка условий                          | `X ≤ 15`, `X % 5 != 0` |

---

## Типы задач и примеры решений

### 1. Поиск наибольшего значения переменной
**Суть задачи:**  
Найти наибольшее целое значение `X`, при котором выражение истинно.

**Пример:**  
Для какого наибольшего целого `X` истинно выражение:  
`(X < 25) И НЕ((X чётное) И (X > 15))`

**Решение:**  
1. Упростим выражение:  
   - `НЕ(X чётное И X > 15)` → `X нечётное ИЛИ X ≤ 15`.  
   - Итоговое условие: `(X < 25) И (X нечётное ИЛИ X ≤ 15)`.  
2. Ищем наибольшее `X`:  
   - Максимальное `X < 25` → `X = 24` (чётное и >15 → не подходит).  
   - Проверяем `X = 23` (нечётное и <25 → **подходит**).  

**Ответ:** 23.

---

### 2. Поиск наименьшего значения переменной
**Суть задачи:**  
Найти наименьшее целое `X`, удовлетворяющее условию.

**Пример:**  
Для какого наименьшего целого `X` ложно выражение:  
`(X < 10) ИЛИ (X делится на 3)`

**Решение:**  
1. Выражение ложно, когда:  
   - `X ≥ 10` **И** `X не делится на 3`.  
2. Ищем наименьшее `X`:  
   - Наименьшее `X ≥ 10` → `X = 10` (не делится на 3 → **подходит**).  

**Ответ:** 10.

---

### 3. Поиск неизвестного числа
**Суть задачи:**  
Найти число с заданными свойствами (например, в определённой системе счисления).

**Пример:**  
Некоторое число `X` в двоичной системе заканчивается на `100` и делится на 5. Найдите наименьшее такое `X`.

**Решение:**  
1. Число в двоичной системе: `...100` (последние 3 цифры → `X = 4k + 4`).  
2. Условие: `X` делится на 5 → `4k + 4 = 5m`.  
3. Подбираем наименьшее `k`:  
   - `k = 4` → `X = 4×4 + 4 = 20` (двоичная запись: `10100` → заканчивается на `100`).  

**Ответ:** 20.

---

## Другие возможные типы задач
- **Логические выражения с множеством переменных:**  
  *Пример:* Найти все пары `(X, Y)`, при которых истинно `(X + Y < 10) И (X > 2)`.  
- **Числа с особыми свойствами:**  
  *Пример:* Трёхзначное число, сумма цифр которого равна 12 и оно кратно 4.  
- **Задачи на системы счисления:**  
  *Пример:* Число `23102310` записали в двоичной системе. Сколько единиц содержит эта запись?

---

## Итог
1. **Для поиска наибольшего/наименьшего значения:**  
   - Перебирайте значения от крайних (макс. или мин.) к средним.  
   - Проверяйте каждое значение на соответствие условию.  
2. **Для поиска неизвестного числа:**  
   - Используйте перевод между системами счисления.  
   - Составляйте уравнения на основе условий.  
3. **Советы:**  
   - Внимательно читайте условие (например, «ложно» вместо «истинно»).  
   - Проверяйте все возможные варианты, если задача неоднозначна.  
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 4",
                        image = null,
                        content = """
   # Тема: Формальные описания реальных объектов и процессов (анализ схем и таблиц)

   ## Основные понятия
   **Формальное описание** — это упрощённое, точное и строгое представление объекта или процесса, где:
   - Каждый параметр чётко определён;
   - Нет двусмысленностей;
   - Можно однозначно проследить поведение системы.

   ---

   ## Типы задач и примеры решений

   ### 1. Анализ схемы (графа или алгоритма)
   **Суть задачи:**  
   Анализ блок-схемы, графа состояний или алгоритма для определения:
   - Количества шагов до результата;
   - Поведения объекта;
   - Значений переменных;
   - Условий переходов.

   **Пример:**  
   Робот движется по коридору с участками A, B, C, D. Возможные переходы:  
   - A → B → D  
   - A → C → D  

   **Вопрос:**  
   Сколько различных путей от A до D, если робот не повторяет участки?

   **Решение:**  
   1. Построим граф переходов:  
      - Путь 1: `A → B → D`  
      - Путь 2: `A → C → D`  
   2. Итог: **2 пути**.  

   **Ответ:** 2.

   ---

   ### 2. Анализ таблицы
   **Суть задачи:**  
   Работа с таблицами, описывающими параметры, переходы или состояния. Необходимо:  
   - Найти подходящие строки;  
   - Определить условия событий;  
   - Сопоставить данные для выводов.

   #### Пример 1: Автомат по продаже напитков
   | Состояние | Ввод          | Переход в | Действие       |
   |-----------|---------------|-----------|----------------|
   | 0         | монета 10 руб | 10        | -              |
   | 10        | монета 10 руб | 20        | -              |
   | 20        | монета 10 руб | 30        | выдать воду    |
   | 20        | кнопка «вода» | 20        | -              |

   **Вопрос:**  
   Что произойдёт, если вставить две монеты по 10 руб и нажать кнопку «вода»?

   **Решение:**  
   1. Состояние 0 → монета → состояние 10.  
   2. Состояние 10 → монета → состояние 20.  
   3. Состояние 20 → кнопка «вода» → остаётся в 20.  

   **Ответ:** Ничего не произойдёт.

   #### Пример 2: Режимы стиральной машины
   | Режим    | Температура | Время (мин) | Отжим |
   |----------|-------------|-------------|-------|
   | Быстрый  | 30°C        | 20          | Да    |
   | Деликат  | 40°C        | 40          | Нет   |
   | Стирка   | 60°C        | 60          | Да    |

   **Вопрос:**  
   Какой режим подойдёт для быстрой стирки без отжима?

   **Решение:**  
   - Быстрая стирка → короткое время (20-40 мин).  
   - Без отжима → «Отжим = Нет».  

   **Ответ:** Деликат (40 мин, без отжима).

   ---

   ## Полезные советы
   | Совет                          | Почему это важно                     |
   |--------------------------------|---------------------------------------|
   | Внимательно читай таблицу/схему | Всё уже указано — нужно только сопоставить данные. |
   | Отслеживай последовательность  | Ошибки возникают из-за пропущенных шагов. |
   | Ищи запреты и ограничения      | Правильный ответ часто исключает нарушение правил. |
   | Составь мини-таблицу вручную   | Визуализация помогает быстрее найти решение. |
   | Пробуй варианты «в уме»        | Логический перебор упрощает задачу. |

   ---

   ## Заключение
   | Тип задачи       | Действия                              |
   |------------------|---------------------------------------|
   | **Анализ схемы** | Проследить путь, понять логику переходов, условия. Учитесь «читать» элементы (И, ИЛИ, НЕ). |
   | **Анализ таблицы** | Выбрать верный вариант на основе условий. Тренируйтесь быстро находить нужные данные. |
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 5",
                        image = null,
                        content = """
   # Тема: Простой линейный алгоритм для формального исполнителя

   ## Общие понятия
   - **Линейный алгоритм** — последовательность операций, выполняемых строго по порядку без циклов и сложных ветвлений.
   - **Формальный исполнитель** — абстрактная модель (робот, программа), выполняющая команды в заданном порядке.

   **Основные задачи:**
   1. Получение большего числа из пары.
   2. Получение меньшего числа из пары.

   ---

   ## Типы задач и примеры решений

   ### 1. Получение большего числа из меньшего
   **Суть задачи:**  
   Найти минимальное количество команд для преобразования исходного числа в целевое с помощью операций (например, сложение, умножение).

   **Пример:**  
   У бортового калькулятора корабля «Гиперон-7» есть функции:   
   1. Прибавить 2.  
   2. Умножить на 3.  

   **Вопрос:**  
   Какое минимальное число команд нужно, чтобы из числа 3 получить 15?

   **Решение:**  
   1. **Обратный анализ:**  
      - 15 → могло быть получено из 5 (15 / 3) или 13 (15 - 2).  
      - Выбираем путь через умножение: **5** → **3** (5 - 2).  
   2. **Последовательность команд:**  
      - 3 → +2 → 5 → ×3 → 15.  

   **Ответ:** 2 команды.

   ---

   ### 2. Получение меньшего числа из большего
   **Суть задачи:**  
   Преобразовать число с помощью операций уменьшения (вычитание, деление) с учётом ограничений (например, деление только нацело).

   **Пример:**  
   Исполнитель «Делитель» выполняет команды:  
   1. Вычесть 1.  
   2. Разделить на 2 (если число чётное).  

   **Вопрос:**  
   Какое минимальное число команд нужно, чтобы из числа 20 получить 3?

   **Решение:**  
   1. **Обратный анализ:**  
      - 3 → могло быть получено из 4 (3 + 1) или 6 (3 × 2).  
      - Оптимальный путь:  
        - 20 → 19 (-1) → 18 (-1) → 9 (/2) → 8 (-1) → 4 (/2) → 3 (-1).  
   2. **Последовательность команд:**  
      - -1, -1, /2, -1, /2, -1.  

   **Ответ:** 6 команд.

   ---

   ### 3. Комбинации арифметических операций
   **Пример:**  
   Энергоблок корабля имеет функции:  
   1. Прибавить 3.  
   2. Умножить на 2.  

   **Вопрос:**  
   Как из числа 4 получить 26 за минимальное число шагов?

   **Решение:**  
   1. **Обратный анализ:**  
      - 26 → 13 (26 / 2) → 10 (13 - 3) → 5 (10 / 2) → 2 (5 - 3) → 4 (2 × 2).  
   2. **Последовательность команд:**  
      - ×2, +3, ×2, +3, ×2.  

   **Ответ:** 5 команд.

   ---

   ### 4. Ограничения на команды
   **Пример:**  
   Исполнитель может:  
   1. Вычесть 1.  
   2. Разделить на 3 (если число кратно 3).  

   **Вопрос:**  
   Как из числа 30 получить 2?

   **Решение:**  
   1. **Последовательность:**  
      - 30 → 10 (/3) → 9 (-1) → 3 (/3) → 2 (-1).  
   2. **Команды:**  
      - /3, -1, /3, -1.  

   **Ответ:** 4 команды.

   ---

   ## Советы по решению
   1. **Обратный анализ** — начинайте с целевого числа и двигайтесь к исходному.  
   2. **Минимизация команд:**  
      - Используйте умножение/деление вместо сложения/вычитания.  
   3. **Проверка делимости** — убедитесь, что число делится нацело на каждом шаге.  
   4. **Избегайте тупиков** — если путь не ведёт к цели, вернитесь и измените стратегию.  

   ---

   **Итог:**  
   - Для задач на умножение/деление обратный анализ часто эффективнее.  
   - Всегда проверяйте альтернативные пути выполнения команд.  
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 6",
                        image = null,
                        content = """ 
   # Тема: Анализ программ с условными операторами

   Это задание проверяет понимание логических условий, умение анализировать код на разных языках программирования, умение применять условие программы к конкретным входным данным.

   ---

   ## Что такое условный оператор

   Условный оператор позволяет программе выбирать один из двух (или более) вариантов действий в зависимости от истинности какого-либо логического выражения. Обычно он записывается в виде конструкции:

   ```
   Если (условие) то
       выполнить действия A
   Иначе
       выполнить действия B
   Конец
   ```

   В большинстве языков программирования условный оператор записывается с использованием операторов сравнения (например, `>`, `<`, `==`) и логических операторов (например, `OR`, `AND`, `NOT`).

   ---

   ## Оператор OR

   Логический оператор `OR` (ИЛИ) возвращает истину, если хотя бы одно из сравниваемых выражений истинно. То есть выражение:

   ```
   условие1 OR условие2
   ```

   будет истинным, если выполнено **хотя бы одно** из условий (или оба).

   ---

   ## Стандартный алгоритм с условным оператором

   Программа, использующая условный оператор, обычно имеет следующий алгоритм:

   1. Считывание входных данных (например, двух чисел, переменных `s` и `t`).
   2. Вычисление логического условия, например:
      ```
      если s > 8 или t > 8
      ```
   3. Если условие истинно — выполнить одни действия (например, вывести `YES`).
   4. Если условие ложно — выполнить другие действия (например, вывести `NO`).

   ---

   ## Пример на разных языках программирования

   **Бейсик:**
   ```basic
   DIM s, t AS INTEGER
   INPUT s
   INPUT t
   IF s > 8 OR t > 8 THEN
       PRINT 'YES'
   ELSE
       PRINT 'NO'
   ENDIF
   ```

   **Python:**
   ```python
   s = int(input())
   t = int(input())
   if s > 8 or t > 8:
       print('YES')
   else:
       print('NO')
   ```

   **Паскаль:**
   ```pascal
   var s, t: integer;
   begin
     readln(s);
     readln(t);
     if (s > 8) or (t > 8) then
       writeln('YES')
     else
       writeln('NO');
   end.
   ```

   **Алгоритмический язык:**
   ```
   алг
   нач
     цел s, t
     ввод s
     ввод t
     если s > 8 или t > 8 то
         вывод "YES"
     иначе
         вывод "NO"
     все
   кон
   ```

   **C++:**
   ```cpp
   #include <iostream>
   using namespace std;
   int main() {
       int s, t;
       cin >> s;
       cin >> t;
       if (s > 8 || t > 8)
           cout << "YES";
       else
           cout << "NO";
       return 0;
   }
   ```

   ---

   ## Анализ запусков программы

   Было проведено **9 запусков**, при которых вводились следующие пары чисел:

   ```
   (8, 8), (9, 6), (4, 7), (6, 6), (–9, –2), (–5, 9), (–10, 10), (6, 9), (10, 6)
   ```

   Условие программы:
   > если s > 8 или t > 8

   ### Разбор по парам:

   1. **(8, 8)**  
      - 8 > 8 → ❌  
      - 8 > 8 → ❌  
      → `NO`

   2. **(9, 6)**  
      - 9 > 8 → ✅  
      - 6 > 8 → ❌  
      → `YES`

   3. **(4, 7)**  
      - 4 > 8 → ❌  
      - 7 > 8 → ❌  
      → `NO`

   4. **(6, 6)**  
      - 6 > 8 → ❌  
      - 6 > 8 → ❌  
      → `NO`

   5. **(–9, –2)**  
      - –9 > 8 → ❌  
      - –2 > 8 → ❌  
      → `NO`

   6. **(–5, 9)**  
      - –5 > 8 → ❌  
      - 9 > 8 → ✅  
      → `YES`

   7. **(–10, 10)**  
      - –10 > 8 → ❌  
      - 10 > 8 → ✅  
      → `YES`

   8. **(6, 9)**  
      - 6 > 8 → ❌  
      - 9 > 8 → ✅  
      → `YES`

   9. **(10, 6)**  
      - 10 > 8 → ✅  
      - 6 > 8 → ❌  
      → `YES`

   ---

   ## Ответ

   Из 9 запусков программа вывела `"YES"` в следующих случаях:

   - (9, 6)
   - (–5, 9)
   - (–10, 10)
   - (6, 9)
   - (10, 6)

   **Итого: `5` запусков.**

   **Ответ: `5`**
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 7",
                        image = null,
                        content = """
   # Тема: Работа с IP-адресами, электронной почтой и адресами файлов

   ## Что такое адрес в ИКТ
   В информационно-коммуникационных технологиях адреса используются для однозначной идентификации объектов в сети или в файловой системе. К таким адресам относятся:
   - **IP-адреса** – уникальные цифровые обозначения, позволяющие идентифицировать устройства в компьютерных сетях.
   - **Адреса почтовых ящиков** – стандартное представление адреса электронной почты, позволяющее отправлять и получать сообщения.
   - **Адреса файлов (URL или пути)** – используются для указания местоположения файла в сети (URL) или на локальном устройстве.

   В заданиях могут встречаться разные задачи, разделённые по типам в зависимости от того, какой адрес нужно восстановить или закодировать.

   ---

   ## Типы задач и примеры решений

   ### 1. Восстановление IP-адреса
   **Описание:**
   - Задание может требовать восстановления IP-адреса по заданной кодировке или последовательности чисел.
   - Обычно используется формат IPv4: четыре октета, разделённые точками (например, `192.168.0.1`).
   - Иногда число записано подряд, и нужно правильно разбить его на октеты, учитывая, что каждое число должно быть от 0 до 255.

   **Ключевые моменты:**
   - Понимание формата IPv4.
   - Умение разделить заданную числовую строку на четыре корректных части.

   **Пример:**  
   Дана числовая строка «192168000001». Известно, что это IP-адрес в формате IPv4, записанный без точек. Восстановите адрес.

   **Решение:**
   1. Формат IPv4 – четыре октета, каждый число от 0 до 255.
   2. Разобьём строку:
      - Первый октет: `192`
      - Второй октет: `168`
      - Третий октет: `000` → `0` (ведущие нули можно отбросить)
      - Четвёртый октет: `001` → `1`
   3. Собираем адрес с точками: `192.168.0.1`.

   **Пояснение:**  
   Нужно знать, что IPv4 состоит из четырёх чисел, каждое из которых не превышает 255. Разбив строку последовательностью цифр на логически корректные группы, получаем корректный IP-адрес.

   ---

   ### 2. Кодировка (или шифрование) адреса почтового ящика
   **Описание:**
   - В задании для почтового ящика часто даётся своя таблица соответствий для букв, цифр или специальных символов, используемых в адресе.
   - Алгоритм может включать замену символов на числа или специальные знаки.

   **Пример таблицы соответствий:**
   | Символ | Код |
   |--------|-----|
   | @      | 01  |
   | .      | 02  |
   | A      | 03  |
   | B      | 04  |
   | C      | 05  |
   | ...    | ... |

   **Задача:**  
   На почтовом дроне с планеты Техноларий получено зашифрованное имя получателя: 03040501060702. 
   Известно, что оно зашифровано с помощью таблицы из командного центра:
   
   | Символ | Код |
   |--------|-----|
   | @      | 01  |
   | .      | 02  |
   | A      | 03  |
   | B      | 04  |
   | C      | 05  |
   | ...    | ... |

   **Решение:**
   1. Разбиваем строку на пары цифр: `03`, `04`, `05`, `01`, `06`, `07`, `02`.
   2. Сопоставляем по таблице:
      - `03` → `A`
      - `04` → `B`
      - `05` → `C`
      - `01` → `@`
      - `06` → `D`
      - `07` → `E`
      - `02` → `.`
   3. Итоговая последовательность: `ABC@DE`.

   **Пояснение:**  
   Важно разбить строку на заданные части (например, по 2 цифры), применить таблицу соответствий и собрать адрес. Пример: `ABC@DE.com`.

   ---

   ### 3. Кодировка адреса файла (URL или путь)
   **Описание:**
   - Требуется восстановить или закодировать адрес файла, используя фрагменты.
   - Адрес может включать протокол, доменное имя, путь к файлу и расширение.

   **Пример:**  
   Даны фрагменты адреса:
   1. `http`
   2. `://`
   3. `site`
   4. `.com`
   5. `/folder`
   6. `/file`
   7. `.txt`

   **Решение:**  
   Собираем фрагменты в правильном порядке:  
   `http://site.com/folder/file.txt`.

   **Пояснение:**  
   Стандартный формат URL:  
   `протокол://домен/путь/файл.расширение`.

   ---

   ## Рекомендации при решении
   1. **Внимательно читайте условие и таблицы соответствий.**
   2. **Разделяйте входную строку на логические блоки.**
   3. **Знайте стандарты форматов** (IPv4, URL, email).
   4. **Собирайте адрес в правильном порядке.**
   5. **Проверяйте корректность** (например, октеты IP-адреса ≤ 255).
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 8",
                        image = null,
                        content = """
   # Тема: Работа с логическими запросами (И, ИЛИ, НЕ) и расчёт количества найденных страниц

   ## Основные понятия
   1. **Поисковые запросы** — цепочки ключевых слов и логических операторов, которые помогают поисковой системе отобрать нужные страницы.
   2. **Логические операторы в запросах**:
      - **И (AND)** — страницы, где есть оба слова.
      - **ИЛИ (OR)** — страницы, где есть хотя бы одно из слов.
      - **НЕ (NOT)** — страницы, где нет указанного слова.
   3. **Формула включений-исключений**:
      - Для двух запросов:  
        `|A∪B| = |A| + |B| − |A∩B|`  
        где:
        - `|A∪B|` — количество страниц по запросу A ИЛИ B,
        - `|A|`, `|B|` — количество страниц по каждому запросу,
        - `|A∩B|` — количество страниц по запросу A И B.

   ---

   ## Типы задач и примеры решений

   ### 1. Запрос из одного слова
   **Задача**:  
   По запросу `Крейсер | Линкор` найдено 3700 страниц, `Крейсер & Линкор` — 400, `Линкор` — 1800. Найти количество страниц по запросу `Крейсер`.

   **Решение**:  
   Используем формулу включений-исключений:  
   `|Крейсер∪Линкор| = |Крейсер| + |Линкор| − |Крейсер∩Линкор|`  
   Подставляем значения:  
   `3700 = |Крейсер| + 1800 − 400 ⟹ |Крейсер| = 2300`  

   **Ответ**: 2300 тысяч страниц.

   ---

   ### 2. Запрос из двух слов
   **Задача**:  
   По запросу `Пушкин` найдено 3500 страниц, `Лермонтов` — 2000, `Пушкин | Лермонтов` — 4500. Найти количество страниц по запросу `Пушкин & Лермонтов`.

   **Решение**:  
   Формула включений-исключений:  
   `|Пушкин∪Лермонтов| = |Пушкин| + |Лермонтов| − |Пушкин∩Лермонтов|`  
   Подставляем значения:  
   `4500 = 3500 + 2000 − |Пушкин∩Лермонтов| ⟹ |Пушкин∩Лермонтов| = 1000`  

   **Ответ**: 1000 тысяч страниц.

   ---

   ### 3. Запрос из трёх слов
   **Задача**:  
   По запросам `Финляндия & Швеция` найдено 160 страниц, `Финляндия & Норвегия` — 255, `Финляндия & (Швеция | Норвегия)` — 360. Найти количество страниц по запросу `Финляндия & Швеция & Норвегия`.

   **Решение**:  
   Используем формулу для трёх множеств:  
   `|Финляндия∩(Швеция∪Норвегия)| = |Финляндия∩Швеция| + |Финляндия∩Норвегия| − |Финляндия∩Швеция∩Норвегия|`  
   Подставляем значения:  
   `360 = 160 + 255 − |Финляндия∩Швеция∩Норвегия| ⟹ |Финляндия∩Швеция∩Норвегия| = 55`  

   **Ответ**: 55 тысяч страниц.

   ---

   ## Частые ошибки
   1. **Путаница между И и ИЛИ**:
      - `И` уменьшает количество страниц (только общие),
      - `ИЛИ` увеличивает (все страницы с любым из слов).
   2. **Неправильный учёт пересечений**:
      - Если в задаче не указано `|A∩B|`, его нужно найти через формулу.
   3. **Игнорирование тройных пересечений**:
      - В задачах с тремя запросами важно учесть все комбинации.

   ---

   ## Советы по решению
   1. **Рисуйте диаграммы Эйлера-Венна** для визуализации пересечений.
   2. **Проверяйте единицы измерения**: Все данные должны быть в одинаковых единицах (например, тысячи страниц).
   3. **Тренируйтесь на примерах**: Чем больше задач решите, тем лучше запомните формулы.
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 9",
                        image = R.drawable.theory1,
                        content = """ 
   # Тема: Поиск путей в графах между городами с учётом условий (прохождение через пункт или его исключение)

   ## Основные понятия
   - **Граф (схема)** — набор вершин (городов) и рёбер (дорог, связей) между ними.
   - **Путь** — последовательность вершин, в которых каждая пара соседних соединена рёбром.
   - **Простой путь** — путь, который не проходит через одну и ту же вершину более одного раза (исключая, если нужно, начальную/конечную).
   - **Количество путей** — число различных простых путей из первой вершины в целевую.

   ---

   ## Типы задач и примеры решений

   ### 1. Поиск всех путей из города X в город Y
   **Задача**:  
   Перечислить (или посчитать), сколькими разными способами можно добраться из X в Y, не повторяя города.

   **Что делать**:
   1. **Выписать все смежности**:  
      Для каждой вершины запишите, куда из неё можно попасть (смежные вершины).
   2. **Начать перебор**:
      - Старт из X.
      - Для каждой возможной соседней вершины продлить путь, пока не придём в Y.
      - При продлении не возвращаться в уже посещённые вершины.
   3. **Перечислить/посчитать найденные простые пути**.

   **Пример**:  
   На звездной карте изображены маршруты между планетами A, B, C, D, E, F. 
   Каждый маршрут — это односторонний гиперпространственный коридор, по которому можно перемещаться только в указанном направлении (отображён стрелкой). 
   Сколько существует различных путей от планеты A до планеты F, если разрешено использовать любые разрешённые маршруты, но нельзя нарушать направление движения?
   
   ![roads](https://png.pngtree.com/png-clipart/20210129/ourlarge/pngtree-animal-insect-little-bee-png-image_2844405.jpg)

   **Решение**:  
   Количество путей до города X = сумма путей из всех городов, ведущих в X.  
   Посчитаем последовательно:  
   - `A = 1` (старт)  
   - `B = A = 1`  
   - `C = A = 1`  
   - `D = B = 1`  
   - `E = C + B = 2`  
   - `F = D + E = 1 + 2 = 3`  

   **Ответ**: 3.

   ---

   ### 2. Поиск путей, проходящих или не проходящих через заданный город X
   **Формулировки**:
   1. **Обязательный промежуточный пункт**:  
      Сколько путей из A в Z, которые обязательно посещают X хотя бы один раз?
   2. **Исключающий пункт**:  
      Сколько путей из A в Z, не заходя в X?

   **Что делать**:
   1. **Для обязательного пункта X**:
      - Разбейте задачу на два этапа: `A→X` и `X→Z`.
      - Посчитайте пути `A→X` и `X→Z` (не повторяя вершины).
      - Умножьте результаты: `Количество путей A→X × X→Z`.

   2. **Для исключающего пункта X**:
      - Удалите вершину X и связанные рёбра из графа.
      - Посчитайте пути `A→Z` в оставшемся графе.

   **Пример**:  
   На звездной карте изображены маршруты между планетами A, B, C, D, E, F. 
   Каждый маршрут — это односторонний гиперпространственный коридор, по которому можно перемещаться только в указанном направлении (отображён стрелкой). 
   Сколько существует различных путей от планеты A до планеты F с условием, что каждая траектория обязательно должна проходить через планету C?
   
   ![roads](drawable://theory1)

   **Решение**:  
   1. **Пути A→C**:  
      - `A = 1`  
      - `B = A = 1`  
      - `C = A = 1`  

   2. **Пути C→F** (C как старт):  
      - `C = 1`  
      - `E = C = 1`  
      - `F = E = 1`  

   **Ответ**: `1 × 1 = 1`.

   ---

   ## Полезные советы
   - **Выписывайте смежности** в виде списка — это упрощает перебор.
   - **Обход в глубину вручную**: помечайте посещённые вершины.
   - **Для путей через X**: разделяйте задачу на `A→X` и `X→Z`.
   - **Для путей без X**: удалите X из графа и считайте пути в новом графе.
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 10",
                        image = null,
                        content = """ 
   # Сравнение чисел в различных системах счисления. Перевод чисел, поиск наибольшего/наименьшего, сумма и количество цифр

   ## Общая теория: позиционная система счисления

   1. **Основание системы** (base, обозначим `b`) — число различных символов (цифр), используемых для записи чисел.
      - `b = 2` → двоичная (цифры 0, 1)
      - `b = 8` → восьмеричная (0...7)
      - `b = 10` → десятичная (0...9)
      - `b = 16` → шестнадцатеричная (0...9, A...F)

   2. **Позиционная запись числа**:  
      `(dₙdₙ₋₁…d₁d₀)ᵦ  =  dₙ·bⁿ + dₙ₋₁·bⁿ⁻¹ + ⋯ + d₁·b¹ + d₀·b⁰.`.

   3. **Цифры** `dᵢ` — целые от `0` до `b − 1`. В шестнадцатеричной: `A = 10`, `B = 11`, ..., `F = 15`.

   ---

   ## Типы задач и примеры решений

   ### 1. Перевод чисел из одной системы счисления в другую

   **Основные правила**:
   - **В десятичную систему**:  
     `an ⋅ bⁿ + aₙ₋₁ ⋅ bⁿ⁻¹ + ... + a₀⋅b⁰`,  
     где `a_i` — цифры числа, `b` — основание системы.
   - **Из десятичной в другую систему**:  
     Делим число на основание новой системы и записываем остатки в обратном порядке.

   **Пример 1**:  
   Перевести число `1011_2` в десятичную систему.  
   **Решение**:  
   `1 ⋅ 2³ + 0 ⋅ 2² + 1 ⋅ 2¹ + 1 ⋅ 2⁰ = 8 + 0 + 2 + 1 = 11₁₀`.  
   **Ответ**: `11`.

   **Пример 2**:  
   Перевести число `25_{10}` в двоичную систему.  
   **Решение**:  
        25 ÷ 2 = 12 (остаток 1)
        12 ÷ 2 = 6 (остаток 0)
        6 ÷ 2 = 3 (остаток 0)
        3 ÷ 2 = 1 (остаток 1)
        1 ÷ 2 = 0 (остаток 1)
   **Ответ**: `11001_2`.

   ---

   ### 2. Поиск наибольшего/наименьшего числа

   **Стратегия**:
   - Перевести все числа в десятичную систему и сравнить.
   - Или сравнивать по разрядам, если основания систем известны.

   **Пример**:  
   Какое число наибольшее: `1011_2`, `17_8`, `1F_{16}`?  
   **Решение**:  
   - `1011_2 = 11_{10}`  
   - `17_8 = 1⋅8^1 + 7⋅8^0 = 15_{10}`  
   - `1F_{16} = 1⋅16^1 + 15⋅16^0 = 31_{10}`  
   **Ответ**: `1F_{16}`.

   ---

   ### 3. Сумма и количество цифр в записи числа

   **Правила**:
   - **Количество цифр**: Зависит от основания системы. Например, в двоичной системе цифры — 0 и 1.
   - **Сумма цифр**: Сложить все цифры числа в исходной системе.

   **Пример 1**:  
   Сколько цифр в числе `1A7_{16}`?  
   **Ответ**: `3`.

   **Пример 2**:  
   Найти сумму цифр числа `123_4`.  
   **Решение**:  
   `1 + 2 + 3 = 6`.  
   **Ответ**: `6`.

   ---

   ## Итоговые рекомендации

   - Всегда приводите числа к десятичной системе для сравнения.
   - Используйте перевод через степени для `b → 10` и деление для `10 → b`.
   - При работе с суммой/количеством цифр используйте запись в исходной системе.
   - Проверяйте порядок остатков при переводе из десятичной системы.
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 11",
                        image = null,
                        content = """ 
   # Использование поиска в операционной системе и текстовом редакторе

   ## Навыки и задачи
   **Проверяемые умения**:
   - Поиск файлов по названию, содержимому или параметрам (дата, размер)
   - Работа с архивами (распаковка)
   - Анализ текста в файлах для поиска информации

   ---

   ## Инструменты и приёмы

   ### В операционных системах
   | Задача                     | Windows (Проводник)                          | macOS (Finder)                          | Linux (консоль)                     |
   |----------------------------|----------------------------------------------|-----------------------------------------|-------------------------------------|
   | **Поиск по имени/расширению** | Ввести `*.txt` или `имя*.doc` в строке поиска | `Cmd+F` → вкладка «Имя»                 | `find . -name "*.txt"`             |
   | **Поиск по содержимому**      | Фильтр «Содержит» в строке поиска            | `Cmd+F` → вкладка «Содержимое»          | `grep -R "Мармеладов" .`           |
   | **Фильтрация по дате/размеру** | Панель «Дата изменения» / «Размер»          | Параметры поиска                        | `find . -mtime -7` или `-size +1M` |
   | **Поиск в Zip/Tar**           | Распаковать архив → искать в содержимом      | —                                       | `grep -R "ключ" <(tar -xOzf a.tar.gz)` |

   **Советы**:
   - 🔍 Перед поиском распакуйте архив с текстами.
   - 📂 Работайте с самой верхней папкой, чтобы включить все вложенные файлы.

   ---

   ### В текстовых редакторах
   | Приём                      | Windows (Notepad/Word)                     | Notepad++ / VS Code / Sublime          |
   |----------------------------|--------------------------------------------|----------------------------------------|
   | **Простой поиск**            | `Ctrl+F`                                  | `Ctrl+F`                               |
   | **Поиск и замена**           | `Ctrl+H`                                  | `Ctrl+H`                               |
   | **Учёт регистра**            | Опция «Учитывать регистр»                 | Чекбокс «Match Case»                   |
   | **Регулярные выражения**     | Нет (в Word — wildcard-поиск)             | Включить «Use Regular Expression»      |
   | **Поиск во всех файлах**     | Недоступно                                | «Find in Files» (выбор папки)          |
   | **Подсветка вхождений**      | Word: «Найти все»                         | Автоподсветка при вводе запроса        |

   ---

   ## Пошаговый алгоритм решения
   1. **Распакуйте архив** (ZIP/RAR) в отдельную папку.
   2. **Откройте проводник/терминал** и перейдите в распакованный каталог.
   3. **Поиск по имени файла** (пример: `Достоевский` → используйте маски `*.txt` или путь `Проза/Достоевский.txt`).
   4. **Поиск по содержимому**:
      - Введите в строке поиска ОС ключевое слово (например, `Мармеладов`).
      - Система покажет файлы и строки с совпадениями.
   5. **Анализ в редакторе**:
      - Откройте найденный файл.
      - Используйте `Ctrl+F` → `Marmeladov` или `Мармеладов`.
   6. **Определите контекст**:
      - Частые шаблоны: `Мармеладов <Имя>` или `<Имя> Мармеладов`.
   7. **Запишите ответ** (пример: имя «Семён»).
                        """.trimIndent(),
                        isRead = false
                    ),
                    TheoryEntity(
                        title = "Задание 12",
                        image = null,
                        content = """
   # Тема: Использование поисковых средств операционной системы для подсчёта файлов по расширению и объёму.

   Задание проверяет умение работать с файловой системой: находить файлы по заданным критериям (расширение, размер) и подсчитывать их количество.

   ## Общие принципы поисковых средств ОС

   1. Маски файлов  
   – Символ * обозначает «любую последовательность символов»,  
   – Символ ? обозначает «один любой символ».  
   Пример:  
   o *.txt — все файлы с расширением .txt  
   o data_??.csv — файлы data_01.csv, data_A2.csv и т.п.

   2. Фильтры по атрибутам  
   – Дата изменения (сегодня, за неделю…),  
   – Размер (меньше/больше/между).  
   В Windows Проводнике и macOS Finder их можно выбрать из выпадающих списков.

   3. Командная строка / терминал  
   – В Windows PowerShell: Get-ChildItem (alias gci или dir) + -Filter, -Recurse, Where-Object по размеру.  
   – В Linux/macOS: find + -name, -size + wc -l.

   ---

   ## Типы задач и примеры решений

   ### 1. Количество файлов с определённым расширением

   Суть задачи:  
   • Нужно найти все файлы в каталоге (включая подкаталоги) с заданным расширением (например, .txt, .jpg) и определить их количество.

   Пример:  
   На борту межгалактического корабля находится каталог «Документы», содержащий отчёты и инструкции в разных форматах. Используя систему навигации по файлам, просканируй каталог «Документы» и все его межпапочные уровни, чтобы найти все космофайлы с расширением .pdf. Сколько таких файлов найдено?

   Решение:  
   1. Windows:  
   o Откройте каталог «Документы».  
   o В строке поиска проводника введите: *.pdf.  
   o Проводник покажет все файлы PDF. Количество отобразится в строке состояния (например, "Найдено 15 элементов").  
   Ответ: 15.

   ---

   ### 2. Количество файлов с определённым расширением и объёмом

   Суть задачи:  
   • Нужно найти файлы с заданным расширением, размер которых больше/меньше указанного значения (например, .mp3 размером более 5 МБ).

   Пример:  
   В каталоге «Музыка» космической станции хранятся аудиозаписи межзвёздных переговоров и радиопередач. Найди все звуковые капсулы формата .mp3, у которых размер превышает 10 мегабайт — только они содержат полные записи. Сколько таких аудиофайлов было найдено?

   Решение:  
   1. Windows:  
   o Откройте каталог «Музыка».  
   o В строке поиска введите: *.mp3.  
   o Нажмите на кнопку «Поиск» → «Размер» → «Больше 10 МБ».  
   o Количество файлов отобразится внизу окна.  
   Ответ: 8.

   ---

   ## Важные нюансы

   1. Расширение файла:  
   o В Windows расширения могут быть скрыты. Чтобы их отобразить:  
    Перейдите в «Вид» → «Показать/скрыть» → «Расширения имен файлов».

   2. Размер файла:  
   o Единицы измерения:  
    КБ (килобайты), МБ (мегабайты), ГБ (гигабайты).  
   o В поиске Windows можно использовать фильтры:  
    размер: > 10 МБ, размер: < 1 ГБ.

   3. Вложенные каталоги:  
   o Убедитесь, что поиск включает подкаталоги (в Windows галочка «Поиск в подпапках»).
                        """.trimIndent()
                    ),
                    TheoryEntity(
                        title = "Задание 13",
                        image = null,
                        content = """
   # Тема: Создание презентации или форматирование текста по образцу.

   Это задание проверяет навыки работы с офисными программами (презентации, текстовые редакторы) и умение точно следовать требованиям оформления.  
   Вам предлагается выбрать одно из двух заданий:  
   • 13.1 – создать презентацию  
   • 13.2 – оформить текстовый документ  

   ## Типы задач и примеры решений

   Пример:  
   Выберите ОДНО из предложенных ниже заданий: 13.1 или 13.2.  

   ### 13.1  
   Используя информацию и иллюстративный материал, содержащийся в каталоге «Бурый медведь», создайте презентацию из трех слайдов на тему «Бурый медведь». В презентации должны содержаться краткие иллюстрированные сведения о внешнем виде, об ареале обитания, и образе жизни бурых медведей. Все слайды должны быть выполнены в едином стиле, каждый слайд должен быть озаглавлен.  
   Презентацию сохраните в файле, имя которого Вам сообщат организаторы экзамена. Файл ответа необходимо сохранить в одном из следующих форматов: *.odp, или *.ppt, или *.pptx.

   ### 13.2  
   Создайте в текстовом редакторе документ и напишите в нем следующий текст, точно воспроизведя все оформление текста, имеющееся в образце.  

   Данный текст должен быть набран шрифтом размером 14 пунктов обычного начертания. Отступ первой строки первого абзаца основного текста — 1 см. Расстояние между строками текста не менее одинарного, но не более полуторного междустрочного интервала.  
   Основной текст выровнен по ширине; в ячейках первого столбца таблицы применено выравнивание по левому краю, в ячейках второго и третьего столбцов — по центру. В основном тексте и таблице есть слова, выделенные полужирным, курсивным шрифтом и подчеркиванием. Ширина таблицы меньше ширины основного текста. Таблица выровнена на странице по центру горизонтали.  
   При этом допустимо, чтобы ширина Вашего текста отличалась от ширины текста в примере, поскольку ширина текста зависит от размеров страницы и полей. В этом случае разбиение текста на строки должно соответствовать стандартной ширине абзаца.  
   Интервал между текстом и таблицей не менее 12 пунктов, но не более 24 пунктов.  
   Текст сохраните в файле, имя которого Вам сообщат организаторы. Файл ответа необходимо сохранить в одном из следующих форматов: *.odt, или *.doc, или *.docx.

   ---

   ## Советы

   • Для презентации:  
   o Используйте шаблоны для единого стиля.  
   o Проверьте, чтобы заголовки были краткими и информативными.

   • Для текста:  
   o Включите линейку в редакторе для точных отступов.  
   o Используйте стили абзацев, чтобы не нарушить форматирование.

   **Важно**: Перед сохранением проверьте, что все требования соблюдены, включая названия файлов!
                        """.trimIndent()
                    ),
                    TheoryEntity(
                        title = "Задание 14",
                        image = null,
                        content = """
   # Тема: Обработка данных в электронных таблицах (Excel, Google Sheets и аналоги)

   Это задание проверяет умение работать с формулами, фильтрами и визуализацией данных в электронных таблицах. Основные задачи включают:  
   1. Подсчёт данных по условиям (фильтрация, использование функций).  
   2. Расчёт статистических показателей (среднее, сумма, количество).  
   3. Построение диаграмм на основе отфильтрованных данных.  

   ## Основные приёмы работы с табличными данными

   1. Фильтрация (AutoFilter) — быстро отобрать строки по условию.  
   2. Формулы одномерной выборки  
      - COUNTIF/COUNTIFS — подсчёт числа строк по одному или нескольким условиям.  
      - AVERAGEIF/AVERAGEIFS — вычисление среднего по отфильтрованным строкам.  
   3. Сводные таблицы (Pivot Table) — гибкий способ группировать и агрегировать данные.  
   4. Диаграммы — наглядное представление долей и динамики; здесь — круговая диаграмма.  

   ## Типы задач и примеры решений

   ### 1. Подсчёт количества строк по условиям

   Функции: COUNTIFS (для нескольких условий).  
   Пример задачи:  
   Определите, сколько учеников, сдававших информатику, набрали более 600 баллов.

   Решение:  
   1. Условия:  
      - Столбец C (предмет) = "Информатика".  
      - Столбец D (балл) > 600.  
   2. Формула в ячейку H2:  
   =COUNTIFS(C2:C1001, "Информатика", D2:D1001, ">600")
   Пояснение:  
   - C2:C1001 — диапазон предметов (для 1000 учеников).  
   - D2:D1001 — диапазон баллов.  

   ---

   ### 2. Расчёт среднего значения по условию

   Функции: AVERAGEIFS (для нескольких условий).  
   Пример задачи:  
   Найдите средний балл учеников, сдававших информатику.

   Решение:  
   1. Формула в ячейку H3:  
   =AVERAGEIFS(D2:D1001, C2:C1001, "Информатика")
   2. Форматирование:  
   - Установите для ячейки H3 числовой формат с 2 знаками после запятой (например, 0.00).

   ---

   ### 3. Построение круговой диаграммы

   Пример задачи:  
   Постройте круговую диаграмму по количеству участников из округов «В», «Зел», «З».

   Решение:  
   1. Подготовка данных:  
   Создайте таблицу с кодами округов и их количеством:  
   Округ Количество
   В =COUNTIF(A2:A1001, "В")
   Зел =COUNTIF(A2:A1001, "Зел")
   З =COUNTIF(A2:A1001, "З")
   2. Построение диаграммы:  
   - Выделите таблицу с кодами и количеством.  
   - Вставьте круговую диаграмму:  
     - В Excel: «Вставка» → «Круговая диаграмма».  
   - Настройте диаграмму:  
     - Добавьте подписи данных (проценты или значения).  
     - Переместите диаграмму рядом с ячейкой G6.

   ---

   ## Важные нюансы

   • Диапазоны: Убедитесь, что диапазон данных охватывает все 1000 строк (например, A2:A1001).  
   • Условия в формулах:  
   - Текст в условиях пишется в кавычках: "Информатика", "В".  
   - Для чисел используются операторы: ">600", "<=500".  
   • Форматирование диаграммы:  
   - Диаграмма должна быть подписана (название, легенда).  
   - Размер и положение диаграммы должны соответствовать заданию.

   ---

   ## Советы

   • Проверка данных: Убедитесь, что в столбце «предмет» нет опечаток (например, «Информатика» vs «Информ.»).  
   • Абсолютные ссылки: Если данные находятся на другом листе, используйте ссылки с ! (например, Лист1!A2:A1001).  
   • Тестирование: Проверьте формулы на небольшом фрагменте данных перед применением ко всей таблице.
                        """.trimIndent()
                    ),
                    TheoryEntity(
                        title = "Задание 15",
                        image = null,
                        content = """# Тема: Составление алгоритмов для движения и закрашивания клеток в лабиринте с учётом условий

## Структура «коротких» алгоритмов

### 1. Команды приказы
- Простые действия, выполняемые один за другим, без разветвлений.
- Примеры: вверх, вправо, закрасить.

### 2. Условные операторы
если <условие> то
<команды приказы>
все
- <условие> — проверка (сверху свободно, не справа свободно, логические связки и, или, не).
- Ветвь «то» выполняется только при истинности условия.

### 3. Циклы «пока»
нц пока <условие>
<команды приказы>
кц

- Повторяют <команды приказы>, пока <условие> истинно.

### 4. Логические связки
- и (AND), или (OR), не (NOT).
- Пример: (справа свободно) и (не снизу свободно).

## Типы задач и примеры решений

### 1. Движение вдоль горизонтальной стены
Цель: Закрасить все клетки ниже горизонтальной стены, пропуская проходы.  
Условия:
- Робот стартует под левым концом горизонтальной стены.
- Проход в стене — это место, где сверху свободно.

Алгоритм:
нц пока справа свободно
если сверху свободно то
// Проход — не закрашиваем
иначе
закрасить
все
вправо
кц


Пояснение:
- Робот движется вправо, проверяя наличие стены сверху.
- Если стена есть (сверху не свободно), закрашивает клетку.
- Если сверху свободно (проход), пропускает закрашивание.

---

### 2. Движение вдоль вертикальной стены
Цель: Закрасить все клетки левее вертикальной стены, пропуская проходы.  
Условия:
- После горизонтальной стены Робот оказывается у вертикальной.
- Проход в вертикальной стене — это место, где слева свободно.

Алгоритм:
вниз // Переход к вертикальной стене
нц пока снизу свободно
если слева свободно то
// Проход — не закрашиваем
иначе
закрасить
все
вниз
кц


Пояснение:
- Робот спускается вниз вдоль вертикальной стены.
- Если слева стена (не свободно), закрашивает клетку.
- Если слева свободно (проход), пропускает закрашивание.

---

### 3. Полный алгоритм
Цель: Закрасить все клетки ниже горизонтальной и левее вертикальной стен.

Решение:
нц пока справа свободно // Горизонтальная стена
если сверху свободно то
// Проход — пропуск
иначе
закрасить
все
вправо
кц
вниз // Переход к вертикальной стене
нц пока снизу свободно // Вертикальная стена
если слева свободно то
// Проход — пропуск
иначе
закрасить
все
вниз
кц


---

## Важные нюансы

1. Проверка проходов:
   - Проход в горизонтальной стене: сверху свободно.
   - Проход в вертикальной стене: слева свободно.

2. Безопасность Робота:
   - Перед каждым шагом проверяйте, свободен ли путь.
   - Используйте условия, чтобы избежать движения через стены.

3. Универсальность алгоритма:
   - Алгоритм работает для любого расположения проходов и длины стен.

---

## Советы

- Тестирование: Проверьте алгоритм на разных конфигурациях стен.
- Оптимизация: Используйте вложенные циклы, если требуется обход сложных структур.
- Визуализация: Нарисуйте схему движения Робота на бумаге."""
                    ),
                    TheoryEntity(
                        title = "Задание 16",
                        image = null,
                        content = """
# Тема: Обработка последовательностей чисел с условиями

## Общие приёмы

1. Чтение входных данных
   - Сначала читаем целое n — число элементов (обычно 1 ≤ n ≤ 100 ... 1000)
   - Затем n чисел (натуральных либо целых, не превосходящих заданного ограничения)

2. Цикл по всем элементам
for i from 1 to n do
x = next input
...обработка x...
endfor


3. Переменные аккумуляторы
- sum = 0 — для суммирования
- count = 0 — для подсчёта
- max = –∞, min = +∞ — для экстремумов
- flag = false — для проверки наличия

4. Условная обработка
if <условие на x> then
...обновить аккумулятор...
endif


5. Вывод результата
- обычно одно число или несколько чисел в порядке:
print <sum>, <count>, <max>, ...


## Типы задач

1. Сумма чисел по условию (например, кратных заданному числу)
2. Количество элементов (например, чётных, положительных, оканчивающихся на определённую цифру)
3. Поиск экстремумов (максимальное/минимальное число, удовлетворяющее условию)
4. Среднее арифметическое чисел с определёнными свойствами

---

## Пример:
Найти сумму чисел, кратных 6

Алгоритм:
1. Считать количество чисел
2. Инициализировать переменную для суммы
3. Для каждого числа:
- Проверить, делится ли оно на 6
- Если да, добавить к сумме
4. Вывести результат

Код на Python:
```python
n = int(input())
total = 0
for _ in range(n):
 num = int(input())
 if num % 6 == 0:
     total += num
print(total)

## Пояснение:
- `n` — количество чисел
- `total` — накопитель суммы
- `num % 6 == 0` — проверка на кратность 6

---

## Другие типы задач и решения

### 1. Количество чисел, оканчивающихся на 4
```python
n = int(input())
count = 0
for _ in range(n):
    num = int(input())
    if num % 10 == 4:
        count += 1
print(count)

## 2. Поиск максимального чётного числа

Решение:
```python
n = int(input())  # Количество чисел
max_even = -1     # Инициализация начальным значением

for _ in range(n):
    num = int(input())
    # Проверяем чётность и сравниваем с текущим максимумом
    if num % 2 == 0 and num > max_even:
        max_even = num

# Выводим результат с проверкой на отсутствие чётных чисел
print(max_even if max_even != -1 else "Чётных чисел не найдено")

## 3. Расчет среднего арифметического положительных чисел

Полное решение:
```python
# Ввод количества чисел
n = int(input())

# Инициализация переменных-аккумуляторов
sum_positive = 0    # Сумма положительных чисел
count_positive = 0  # Количество положительных чисел

# Обработка каждого числа
for _ in range(n):
    num = int(input())
    if num > 0:      # Проверка на положительность
        sum_positive += num
        count_positive += 1

# Вывод результата с обработкой краевого случая
if count_positive == 0:
    print("Нет положительных чисел")
else:
    average = sum_positive / count_positive
    print(round(average, 2))  # Округление до 2 знаков после запятой

## Советы

- Входные данные: Обращайте внимание на формат ввода (например, числа могут вводиться в одной строке через пробел).

- Проверка условий: Используйте операторы:
  - % (остаток от деления)
  - == (равенство)
  - > (больше)
  - < (меньше)

- Инициализация переменных:
  - Для сумм — 0
  - Для количества — 0
  - Для максимума/минимума — начальное значение (например, -1 или float('-inf'))

- **Обработка краевых случаев**: Учитывайте, что подходящих чисел может не быть (если не указано обратное).
                        """.trimIndent()
                    )
                )
                theoryDao.insertAllTheory(initialData)
            }
        }
    }
}