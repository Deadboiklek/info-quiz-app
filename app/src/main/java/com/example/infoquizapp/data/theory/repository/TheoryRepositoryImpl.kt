package com.example.infoquizapp.data.theory.repository

import android.text.Html
import androidx.compose.ui.res.painterResource
import com.example.infoquizapp.R
import com.example.infoquizapp.data.TheoryDao
import com.example.infoquizapp.data.theory.TheoryEntity
import com.example.infoquizapp.domain.theory.repository.TheoryRepository
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class TheoryRepositoryImpl(private val theoryDao: TheoryDao) : TheoryRepository {
    override suspend fun getTheory(id: Int): TheoryEntity? {
        return theoryDao.getTheoryById(id)
    }

    override suspend fun markTheoryAsRead(id: Int) {
        theoryDao.updateReadStatus(id, true)
    }

    override suspend fun getAllTheory(): List<TheoryEntity> {
        return theoryDao.getAllTheory()
    }

    init {
        CoroutineScope(Dispatchers.IO).launch {
            if (theoryDao.getTheoryCount() == 0) {
                val initialData = listOf(
                    TheoryEntity(
                        title = "Задание 1",
                        image = null,
                        content = """
    **1. Основные понятия**
    
    1. Бит — минимальная единица информации (0 или 1).
    2. Байт = 8 бит.
    3. **Кодировка символов** — способ представления текста в компьютере:
       - **8-битная** (1 байт на символ) → ASCII, КОИ-8 (латиница, кириллица, цифры).
       - **16-битная** (2 байта на символ) → Unicode (UTF-16, поддерживает кириллицу, иероглифы).
       - **32-битная** (4 байта на символ) → UTF-32 (редко, для спецсимволов).
    4. **Формулы:**
       - Объём текста (в битах) = кол-во символов × бит на символ.
       - Перевод в байты: биты ÷ 8.
       - Перевод в КБ: байты ÷ 1024.

    **2. Типы задач и примеры решений**

    **1. Задачи на удаление слова из текста**
    
    **Алгоритм решения:**
    1. Определить, сколько байт занимает вычеркнутое слово.
    2. Учесть удаление лишних запятых и пробелов (обычно 2 символа).
    3. Составить уравнение на основе изменения размера текста.

    **Пример 1 (8-битная кодировка):**
    
    В кодировке КОИ-8 каждый символ кодируется 8 битами.  
    Текст: «Обь, Лена, Волга, Москва, Макензи, Амазонка — реки».  
    После удаления названия реки размер уменьшился на 8 байт. Какое слово вычеркнули?

    **Решение:**
    1. Размер уменьшился на 8 байт = 64 бита (1 байт = 8 бит).
    2. При удалении слова также удаляются 2 символа (запятая и пробел).
       - Их размер: 2 × 8 бит = 16 бит.
    3. Пусть длина вычеркнутого слова = L. Тогда:
       - L × 8 (бит) + 16 (бит) = 64 (бит)
       - L = (64-16)/8 = 6 символов
    4. Ищем слово из 6 букв: **Москва**.
    
    **Ответ:** Москва.

    **Пример 2 (16-битная кодировка):**
    
    В Unicode каждый символ кодируется 16 битами.  
    Текст: «Ель, кедр, сосна, кипарис, лиственница, можжевельник — хвойные растения».  
    После удаления слова размер уменьшился на 26 байт. Какое слово вычеркнули?

    **Решение:**
    1. Размер уменьшился на 26 байт = 208 бит.
    2. Удалено 2 символа: 2 × 16 бит = 32 бита.
    3. Уравнение:
       - L × 16 + 32 = 208
       - L = (208-32)/16 = 11 символов
    4. Ищем слово из 11 букв: **лиственница**.
    
    **Ответ:** лиственница.

    **Пример 3 (32-битная кодировка):**
    
    В UTF-32 каждый символ кодируется 32 битами.  
    Текст: «Айва, Алыча, Генипа, Гуарана, Курбарил, Мангостан — фрукты».  
    После удаления слова размер уменьшился на 36 байт. Какое слово вычеркнули?

    **Решение:**
    1. Размер уменьшился на 36 байт = 288 бит.
    2. Удалено 2 символа: 2 × 32 бит = 64 бита.
    3. Уравнение:
       - L × 32 + 64 = 288
       - L = (288-64)/32 = 7 символов
    4. Ищем слово из 7 букв: **Гуарана**.
    
    **Ответ:** Гуарана.

    **2. Задачи на расчёт объёма статьи**

    **Пример:**
    
    Статья содержит 30 страниц, на каждой 60 строк, в каждой строке 52 символа.  
    Символы кодируются в Unicode (2 байта на символ).  
    Определите объём статьи в КБ.

    **Решение:**
    1. Общее количество символов:
       - 30 стр. × 60 строк × 52 символа = 93600 символов
    2. Объём в байтах:
       - 93600 × 2 байта = 187200 байт
    3. Переводим в КБ:
       - 187200 ÷ 1024 = 182,8 КБ
    4. Округляем до целых, так как в ОГЭ обычно требуется точный ответ.

    **Ответ:** 183 КБ.

    **Важно:**
    - Внимательно читайте условие (может быть указано "без лишних пробелов").
    - Проверяйте единицы измерения (биты, байты, КБ).
""".trimIndent(),
                        isRead = false
                    ),
                    TheoryEntity(
                        title = "Задание 2",
                        image = null,
                        content = """ 
# Тема: Анализ и декодирование информации (шифры, кодирование, однозначность расшифровки)

## 1. Шифрование букв номерами в алфавите
**Суть задачи:**
- Каждой букве русского алфавита присваивается номер (например, А=1, Б=2, ..., Я=33).
- Шифровка представляет собой последовательность цифр, которую можно разбить на номера букв разными способами.
- Нужно найти шифровку, которая расшифровывается **единственным способом**.

**Особенности:**
- Номера букв могут быть однозначными (1-9) или двузначными (10-33).
- Неоднозначность возникает, если последовательность цифр можно разбить на номера букв несколькими способами.
- **Ключевой признак единственности:**
  - Все числа в возможных разбиениях должны принадлежать диапазону 1-33.
  - Если при разбиении получается число >33, такой вариант недопустим.

---

**Пример:**  
Даны шифровки:  
1. 3102030  
2. 3102033  
3. 3112030  
4. 3112233  

Только одна из них расшифровывается единственным способом. Найдите её.

**Решение:**  
1. **Шифровка 3102030:**  
   - Варианты разбиения:  
     - `3-1-0-2-0-3-0` → 0 недопустим.  
     - `3-10-20-30` → **ВИТЬ** (В=3, И=10, Т=20, Ь=30).  
     - `31-0-20-30` → 0 недопустим.  
   - **Единственный корректный вариант:** ВИТЬ.

2. **Шифровка 3102033:**  
   - Варианты:  
     - `3-10-20-33` → **ВИТЯ**.  
     - `3-10-20-3-3` → **ВИТВВ**.  
   - **Неоднозначно** → не подходит.

3. **Шифровка 3112030:**  
   - Варианты:  
     - `3-1-1-20-30` → ВААТЬ.  
     - `3-11-20-30` → ВЙТЬ.  
     - `31-1-20-30` → ЭАТЬ.  
   - **Неоднозначно** → не подходит.

4. **Шифровка 3112233:**  
   - Варианты:  
     - `3-1-1-22-33` → ВААФЯ.  
     - `31-12-23-3` → ЭКХВ.  
   - **Неоднозначно** → не подходит.

**Ответ:** Шифровка 3102030 (ВИТЬ).

---

## 2. Шифрование с использованием кодовых таблиц
**Суть задачи:**  
- Буквы заменяются комбинациями символов (например, @, ~, +, !, ?, *, -, •, #, ^, ${'$'}).  
- Каждая буква имеет уникальный код.  
- Нужно определить длину сообщения, зная, что буквы не повторяются.  

**Особенности:**  
- Коды могут быть разной длины.  
- Необходимо сопоставить каждую часть шифра с буквой из таблицы, учитывая, что коды не пересекаются.  

---

**Пример:**  
Фрагмент кодовой таблицы:  
- К: @ +  
- Л: ~ +  
- М: + @  
- Н: @ ~ +  
- О: +  
- П: ~  

Сообщение: `+ ~ + ~ + @ @ ~ +`. Определите количество букв, если они не повторяются.  

**Решение:**  
1. **Разбиваем сообщение на коды:**  
   - Последовательность: `+`, `~`, `+`, `~`, `+`, `@`, `@`, `~`, `+`.  
   - Возможные коды:  
     - `+` → О  
     - `~` → П  
     - `@+` → К  
     - `~+` → Л  
     - `+@` → М  
     - `@~+` → Н  

2. **Анализ разбиения:**  
   - `+` → **О**  
   - `~` → **П**  
   - `+@` → **М** (т.к. повторение О недопустимо)  
   - `@~+` → **Н**  
   - Остается `+` → **О** (повторение, исключаем).  

3. **Итоговое разбиение:**  
   - `+` → О  
   - `~` → П  
   - `+@` → М  
   - `@~+` → Н  
   - `~+` → Л  

**Ответ:** 5 букв (О, П, М, Н, Л).

---

## 3. Другие возможные типы задач
- **Шифр Цезаря** (сдвиг букв на определённое число позиций).  
  *Пример:* А → Б, Б → В и т. д.  
- **Двоичное кодирование** (буквы заменяются на двоичные коды фиксированной длины).  
- **Кодирование с использованием условий** (например, буква кодируется её позицией в слове).  

---

## Итог
1. **Для шифров с номерами букв:**  
   - Проверяйте все возможные разбиения.  
   - Отбрасывайте варианты с числами >33 или 0.  

2. **Для кодовых таблиц:**  
   - Сначала ищите самые длинные коды.  
   - Учитывайте условия (например, неповторяющиеся буквы).  

3. **Советы:**  
   - Начинайте с очевидных кодов.  
   - Проверяйте все возможные комбинации.  
   - Если ответ неочевиден, перебирайте варианты шаг за шагом.  
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 3",
                        image = null,
                        content = """ 
# Тема: Работа с переменными, логическими выражениями и числовыми условиями

## Логические операции
| Операция       | Обозначение | Как работает                              | Пример           |
|----------------|-------------|-------------------------------------------|------------------|
| НЕ             | `not A`     | Инвертирует значение A                    | `not (X > 10)`   |
| И              | `A and B`   | Истина, если обе части истинны            | `X > 5 and X < 20` |
| ИЛИ            | `A or B`    | Истина, если хотя бы одна часть истина    | `X % 2 == 0 or X % 3 == 0` |
| Импликация     | `A → B`     | Истина, если из A следует B               | `X < 5 → X < 10` |
| Эквивалентность| `A == B`    | Истина, если A и B равны                  | `X % 2 == 0 == (X чётное)` |
| Неравенства    | `x > 10`    | Проверка условий                          | `X ≤ 15`, `X % 5 != 0` |

---

## Типы задач и примеры решений

### 1. Поиск наибольшего значения переменной
**Суть задачи:**  
Найти наибольшее целое значение `X`, при котором выражение истинно.

**Пример:**  
Для какого наибольшего целого `X` истинно выражение:  
`(X < 25) И НЕ((X чётное) И (X > 15))`

**Решение:**  
1. Упростим выражение:  
   - `НЕ(X чётное И X > 15)` → `X нечётное ИЛИ X ≤ 15`.  
   - Итоговое условие: `(X < 25) И (X нечётное ИЛИ X ≤ 15)`.  
2. Ищем наибольшее `X`:  
   - Максимальное `X < 25` → `X = 24` (чётное и >15 → не подходит).  
   - Проверяем `X = 23` (нечётное и <25 → **подходит**).  

**Ответ:** 23.

---

### 2. Поиск наименьшего значения переменной
**Суть задачи:**  
Найти наименьшее целое `X`, удовлетворяющее условию.

**Пример:**  
Для какого наименьшего целого `X` ложно выражение:  
`(X < 10) ИЛИ (X делится на 3)`

**Решение:**  
1. Выражение ложно, когда:  
   - `X ≥ 10` **И** `X не делится на 3`.  
2. Ищем наименьшее `X`:  
   - Наименьшее `X ≥ 10` → `X = 10` (не делится на 3 → **подходит**).  

**Ответ:** 10.

---

### 3. Поиск неизвестного числа
**Суть задачи:**  
Найти число с заданными свойствами (например, в определённой системе счисления).

**Пример:**  
Некоторое число `X` в двоичной системе заканчивается на `100` и делится на 5. Найдите наименьшее такое `X`.

**Решение:**  
1. Число в двоичной системе: `...100` (последние 3 цифры → `X = 4k + 4`).  
2. Условие: `X` делится на 5 → `4k + 4 = 5m`.  
3. Подбираем наименьшее `k`:  
   - `k = 4` → `X = 4×4 + 4 = 20` (двоичная запись: `10100` → заканчивается на `100`).  

**Ответ:** 20.

---

## Другие возможные типы задач
- **Логические выражения с множеством переменных:**  
  *Пример:* Найти все пары `(X, Y)`, при которых истинно `(X + Y < 10) И (X > 2)`.  
- **Числа с особыми свойствами:**  
  *Пример:* Трёхзначное число, сумма цифр которого равна 12 и оно кратно 4.  
- **Задачи на системы счисления:**  
  *Пример:* Число `23102310` записали в двоичной системе. Сколько единиц содержит эта запись?

---

## Итог
1. **Для поиска наибольшего/наименьшего значения:**  
   - Перебирайте значения от крайних (макс. или мин.) к средним.  
   - Проверяйте каждое значение на соответствие условию.  
2. **Для поиска неизвестного числа:**  
   - Используйте перевод между системами счисления.  
   - Составляйте уравнения на основе условий.  
3. **Советы:**  
   - Внимательно читайте условие (например, «ложно» вместо «истинно»).  
   - Проверяйте все возможные варианты, если задача неоднозначна.  
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 4",
                        image = null,
                        content = """
   # Тема: Формальные описания реальных объектов и процессов (анализ схем и таблиц)

   ## Основные понятия
   **Формальное описание** — это упрощённое, точное и строгое представление объекта или процесса, где:
   - Каждый параметр чётко определён;
   - Нет двусмысленностей;
   - Можно однозначно проследить поведение системы.

   ---

   ## Типы задач и примеры решений

   ### 1. Анализ схемы (графа или алгоритма)
   **Суть задачи:**  
   Анализ блок-схемы, графа состояний или алгоритма для определения:
   - Количества шагов до результата;
   - Поведения объекта;
   - Значений переменных;
   - Условий переходов.

   **Пример:**  
   Робот движется по коридору с участками A, B, C, D. Возможные переходы:  
   - A → B → D  
   - A → C → D  

   **Вопрос:**  
   Сколько различных путей от A до D, если робот не повторяет участки?

   **Решение:**  
   1. Построим граф переходов:  
      - Путь 1: `A → B → D`  
      - Путь 2: `A → C → D`  
   2. Итог: **2 пути**.  

   **Ответ:** 2.

   ---

   ### 2. Анализ таблицы
   **Суть задачи:**  
   Работа с таблицами, описывающими параметры, переходы или состояния. Необходимо:  
   - Найти подходящие строки;  
   - Определить условия событий;  
   - Сопоставить данные для выводов.

   #### Пример 1: Автомат по продаже напитков
   | Состояние | Ввод          | Переход в | Действие       |
   |-----------|---------------|-----------|----------------|
   | 0         | монета 10 руб | 10        | -              |
   | 10        | монета 10 руб | 20        | -              |
   | 20        | монета 10 руб | 30        | выдать воду    |
   | 20        | кнопка «вода» | 20        | -              |

   **Вопрос:**  
   Что произойдёт, если вставить две монеты по 10 руб и нажать кнопку «вода»?

   **Решение:**  
   1. Состояние 0 → монета → состояние 10.  
   2. Состояние 10 → монета → состояние 20.  
   3. Состояние 20 → кнопка «вода» → остаётся в 20.  

   **Ответ:** Ничего не произойдёт.

   #### Пример 2: Режимы стиральной машины
   | Режим    | Температура | Время (мин) | Отжим |
   |----------|-------------|-------------|-------|
   | Быстрый  | 30°C        | 20          | Да    |
   | Деликат  | 40°C        | 40          | Нет   |
   | Стирка   | 60°C        | 60          | Да    |

   **Вопрос:**  
   Какой режим подойдёт для быстрой стирки без отжима?

   **Решение:**  
   - Быстрая стирка → короткое время (20-40 мин).  
   - Без отжима → «Отжим = Нет».  

   **Ответ:** Деликат (40 мин, без отжима).

   ---

   ## Полезные советы
   | Совет                          | Почему это важно                     |
   |--------------------------------|---------------------------------------|
   | Внимательно читай таблицу/схему | Всё уже указано — нужно только сопоставить данные. |
   | Отслеживай последовательность  | Ошибки возникают из-за пропущенных шагов. |
   | Ищи запреты и ограничения      | Правильный ответ часто исключает нарушение правил. |
   | Составь мини-таблицу вручную   | Визуализация помогает быстрее найти решение. |
   | Пробуй варианты «в уме»        | Логический перебор упрощает задачу. |

   ---

   ## Заключение
   | Тип задачи       | Действия                              |
   |------------------|---------------------------------------|
   | **Анализ схемы** | Проследить путь, понять логику переходов, условия. Учитесь «читать» элементы (И, ИЛИ, НЕ). |
   | **Анализ таблицы** | Выбрать верный вариант на основе условий. Тренируйтесь быстро находить нужные данные. |
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 5",
                        image = null,
                        content = """
   # Тема: Простой линейный алгоритм для формального исполнителя

   ## Общие понятия
   - **Линейный алгоритм** — последовательность операций, выполняемых строго по порядку без циклов и сложных ветвлений.
   - **Формальный исполнитель** — абстрактная модель (робот, программа), выполняющая команды в заданном порядке.

   **Основные задачи:**
   1. Получение большего числа из пары.
   2. Получение меньшего числа из пары.

   ---

   ## Типы задач и примеры решений

   ### 1. Получение большего числа из меньшего
   **Суть задачи:**  
   Найти минимальное количество команд для преобразования исходного числа в целевое с помощью операций (например, сложение, умножение).

   **Пример:**  
   Исполнитель «Калькулятор» выполняет команды:  
   1. Прибавить 2.  
   2. Умножить на 3.  

   **Вопрос:**  
   Какое минимальное число команд нужно, чтобы из числа 3 получить 15?

   **Решение:**  
   1. **Обратный анализ:**  
      - 15 → могло быть получено из 5 (15 / 3) или 13 (15 - 2).  
      - Выбираем путь через умножение: **5** → **3** (5 - 2).  
   2. **Последовательность команд:**  
      - 3 → +2 → 5 → ×3 → 15.  

   **Ответ:** 2 команды.

   ---

   ### 2. Получение меньшего числа из большего
   **Суть задачи:**  
   Преобразовать число с помощью операций уменьшения (вычитание, деление) с учётом ограничений (например, деление только нацело).

   **Пример:**  
   Исполнитель «Делитель» выполняет команды:  
   1. Вычесть 1.  
   2. Разделить на 2 (если число чётное).  

   **Вопрос:**  
   Какое минимальное число команд нужно, чтобы из числа 20 получить 3?

   **Решение:**  
   1. **Обратный анализ:**  
      - 3 → могло быть получено из 4 (3 + 1) или 6 (3 × 2).  
      - Оптимальный путь:  
        - 20 → 19 (-1) → 18 (-1) → 9 (/2) → 8 (-1) → 4 (/2) → 3 (-1).  
   2. **Последовательность команд:**  
      - -1, -1, /2, -1, /2, -1.  

   **Ответ:** 6 команд.

   ---

   ### 3. Комбинации арифметических операций
   **Пример:**  
   Исполнитель умеет:  
   1. Прибавить 3.  
   2. Умножить на 2.  

   **Вопрос:**  
   Как из числа 4 получить 26 за минимальное число шагов?

   **Решение:**  
   1. **Обратный анализ:**  
      - 26 → 13 (26 / 2) → 10 (13 - 3) → 5 (10 / 2) → 2 (5 - 3) → 4 (2 × 2).  
   2. **Последовательность команд:**  
      - ×2, +3, ×2, +3, ×2.  

   **Ответ:** 5 команд.

   ---

   ### 4. Ограничения на команды
   **Пример:**  
   Исполнитель может:  
   1. Вычесть 1.  
   2. Разделить на 3 (если число кратно 3).  

   **Вопрос:**  
   Как из числа 30 получить 2?

   **Решение:**  
   1. **Последовательность:**  
      - 30 → 10 (/3) → 9 (-1) → 3 (/3) → 2 (-1).  
   2. **Команды:**  
      - /3, -1, /3, -1.  

   **Ответ:** 4 команды.

   ---

   ## Советы по решению
   1. **Обратный анализ** — начинайте с целевого числа и двигайтесь к исходному.  
   2. **Минимизация команд:**  
      - Используйте умножение/деление вместо сложения/вычитания.  
   3. **Проверка делимости** — убедитесь, что число делится нацело на каждом шаге.  
   4. **Избегайте тупиков** — если путь не ведёт к цели, вернитесь и измените стратегию.  

   ---

   **Итог:**  
   - Для задач на умножение/деление обратный анализ часто эффективнее.  
   - Всегда проверяйте альтернативные пути выполнения команд.  
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 6",
                        image = null,
                        content = """ 
   # Тема: Анализ программ с условными операторами

   Это задание проверяет понимание логических условий, умение анализировать код на разных языках программирования, умение применять условие программы к конкретным входным данным.

   ---

   ## Что такое условный оператор

   Условный оператор позволяет программе выбирать один из двух (или более) вариантов действий в зависимости от истинности какого-либо логического выражения. Обычно он записывается в виде конструкции:

   ```
   Если (условие) то
       выполнить действия A
   Иначе
       выполнить действия B
   Конец
   ```

   В большинстве языков программирования условный оператор записывается с использованием операторов сравнения (например, `>`, `<`, `==`) и логических операторов (например, `OR`, `AND`, `NOT`).

   ---

   ## Оператор OR

   Логический оператор `OR` (ИЛИ) возвращает истину, если хотя бы одно из сравниваемых выражений истинно. То есть выражение:

   ```
   условие1 OR условие2
   ```

   будет истинным, если выполнено **хотя бы одно** из условий (или оба).

   ---

   ## Стандартный алгоритм с условным оператором

   Программа, использующая условный оператор, обычно имеет следующий алгоритм:

   1. Считывание входных данных (например, двух чисел, переменных `s` и `t`).
   2. Вычисление логического условия, например:
      ```
      если s > 8 или t > 8
      ```
   3. Если условие истинно — выполнить одни действия (например, вывести `YES`).
   4. Если условие ложно — выполнить другие действия (например, вывести `NO`).

   ---

   ## Пример на разных языках программирования

   **Бейсик:**
   ```basic
   DIM s, t AS INTEGER
   INPUT s
   INPUT t
   IF s > 8 OR t > 8 THEN
       PRINT 'YES'
   ELSE
       PRINT 'NO'
   ENDIF
   ```

   **Python:**
   ```python
   s = int(input())
   t = int(input())
   if s > 8 or t > 8:
       print('YES')
   else:
       print('NO')
   ```

   **Паскаль:**
   ```pascal
   var s, t: integer;
   begin
     readln(s);
     readln(t);
     if (s > 8) or (t > 8) then
       writeln('YES')
     else
       writeln('NO');
   end.
   ```

   **Алгоритмический язык:**
   ```
   алг
   нач
     цел s, t
     ввод s
     ввод t
     если s > 8 или t > 8 то
         вывод "YES"
     иначе
         вывод "NO"
     все
   кон
   ```

   **C++:**
   ```cpp
   #include <iostream>
   using namespace std;
   int main() {
       int s, t;
       cin >> s;
       cin >> t;
       if (s > 8 || t > 8)
           cout << "YES";
       else
           cout << "NO";
       return 0;
   }
   ```

   ---

   ## Анализ запусков программы

   Было проведено **9 запусков**, при которых вводились следующие пары чисел:

   ```
   (8, 8), (9, 6), (4, 7), (6, 6), (–9, –2), (–5, 9), (–10, 10), (6, 9), (10, 6)
   ```

   Условие программы:
   > если s > 8 или t > 8

   ### Разбор по парам:

   1. **(8, 8)**  
      - 8 > 8 → ❌  
      - 8 > 8 → ❌  
      → `NO`

   2. **(9, 6)**  
      - 9 > 8 → ✅  
      - 6 > 8 → ❌  
      → `YES`

   3. **(4, 7)**  
      - 4 > 8 → ❌  
      - 7 > 8 → ❌  
      → `NO`

   4. **(6, 6)**  
      - 6 > 8 → ❌  
      - 6 > 8 → ❌  
      → `NO`

   5. **(–9, –2)**  
      - –9 > 8 → ❌  
      - –2 > 8 → ❌  
      → `NO`

   6. **(–5, 9)**  
      - –5 > 8 → ❌  
      - 9 > 8 → ✅  
      → `YES`

   7. **(–10, 10)**  
      - –10 > 8 → ❌  
      - 10 > 8 → ✅  
      → `YES`

   8. **(6, 9)**  
      - 6 > 8 → ❌  
      - 9 > 8 → ✅  
      → `YES`

   9. **(10, 6)**  
      - 10 > 8 → ✅  
      - 6 > 8 → ❌  
      → `YES`

   ---

   ## Ответ

   Из 9 запусков программа вывела `"YES"` в следующих случаях:

   - (9, 6)
   - (–5, 9)
   - (–10, 10)
   - (6, 9)
   - (10, 6)

   **Итого: `5` запусков.**

   **Ответ: `5`**
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 7",
                        image = null,
                        content = """
   # Тема: Работа с IP-адресами, электронной почтой и адресами файлов

   ## Что такое адрес в ИКТ
   В информационно-коммуникационных технологиях адреса используются для однозначной идентификации объектов в сети или в файловой системе. К таким адресам относятся:
   - **IP-адреса** – уникальные цифровые обозначения, позволяющие идентифицировать устройства в компьютерных сетях.
   - **Адреса почтовых ящиков** – стандартное представление адреса электронной почты, позволяющее отправлять и получать сообщения.
   - **Адреса файлов (URL или пути)** – используются для указания местоположения файла в сети (URL) или на локальном устройстве.

   В заданиях могут встречаться разные задачи, разделённые по типам в зависимости от того, какой адрес нужно восстановить или закодировать.

   ---

   ## Типы задач и примеры решений

   ### 1. Восстановление IP-адреса
   **Описание:**
   - Задание может требовать восстановления IP-адреса по заданной кодировке или последовательности чисел.
   - Обычно используется формат IPv4: четыре октета, разделённые точками (например, `192.168.0.1`).
   - Иногда число записано подряд, и нужно правильно разбить его на октеты, учитывая, что каждое число должно быть от 0 до 255.

   **Ключевые моменты:**
   - Понимание формата IPv4.
   - Умение разделить заданную числовую строку на четыре корректных части.

   **Пример:**  
   Дана числовая строка «192168000001». Известно, что это IP-адрес в формате IPv4, записанный без точек. Восстановите адрес.

   **Решение:**
   1. Формат IPv4 – четыре октета, каждый число от 0 до 255.
   2. Разобьём строку:
      - Первый октет: `192`
      - Второй октет: `168`
      - Третий октет: `000` → `0` (ведущие нули можно отбросить)
      - Четвёртый октет: `001` → `1`
   3. Собираем адрес с точками: `192.168.0.1`.

   **Пояснение:**  
   Нужно знать, что IPv4 состоит из четырёх чисел, каждое из которых не превышает 255. Разбив строку последовательностью цифр на логически корректные группы, получаем корректный IP-адрес.

   ---

   ### 2. Кодировка (или шифрование) адреса почтового ящика
   **Описание:**
   - В задании для почтового ящика часто даётся своя таблица соответствий для букв, цифр или специальных символов, используемых в адресе.
   - Алгоритм может включать замену символов на числа или специальные знаки.

   **Пример таблицы соответствий:**
   | Символ | Код |
   |--------|-----|
   | @      | 01  |
   | .      | 02  |
   | A      | 03  |
   | B      | 04  |
   | C      | 05  |
   | ...    | ... |

   **Задача:**  
   Дана закодированная строка: `03040501060702`. Восстановите адрес почтового ящика.

   **Решение:**
   1. Разбиваем строку на пары цифр: `03`, `04`, `05`, `01`, `06`, `07`, `02`.
   2. Сопоставляем по таблице:
      - `03` → `A`
      - `04` → `B`
      - `05` → `C`
      - `01` → `@`
      - `06` → `D`
      - `07` → `E`
      - `02` → `.`
   3. Итоговая последовательность: `ABC@DE`.

   **Пояснение:**  
   Важно разбить строку на заданные части (например, по 2 цифры), применить таблицу соответствий и собрать адрес. Пример: `ABC@DE.com`.

   ---

   ### 3. Кодировка адреса файла (URL или путь)
   **Описание:**
   - Требуется восстановить или закодировать адрес файла, используя фрагменты.
   - Адрес может включать протокол, доменное имя, путь к файлу и расширение.

   **Пример:**  
   Даны фрагменты адреса:
   1. `http`
   2. `://`
   3. `site`
   4. `.com`
   5. `/folder`
   6. `/file`
   7. `.txt`

   **Решение:**  
   Собираем фрагменты в правильном порядке:  
   `http://site.com/folder/file.txt`.

   **Пояснение:**  
   Стандартный формат URL:  
   `протокол://домен/путь/файл.расширение`.

   ---

   ## Рекомендации при решении
   1. **Внимательно читайте условие и таблицы соответствий.**
   2. **Разделяйте входную строку на логические блоки.**
   3. **Знайте стандарты форматов** (IPv4, URL, email).
   4. **Собирайте адрес в правильном порядке.**
   5. **Проверяйте корректность** (например, октеты IP-адреса ≤ 255).
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 8",
                        image = null,
                        content = """
   # Тема: Работа с логическими запросами (И, ИЛИ, НЕ) и расчёт количества найденных страниц

   ## Основные понятия
   1. **Поисковые запросы** — цепочки ключевых слов и логических операторов, которые помогают поисковой системе отобрать нужные страницы.
   2. **Логические операторы в запросах**:
      - **И (AND)** — страницы, где есть оба слова.
      - **ИЛИ (OR)** — страницы, где есть хотя бы одно из слов.
      - **НЕ (NOT)** — страницы, где нет указанного слова.
   3. **Формула включений-исключений**:
      - Для двух запросов:  
        `|A∪B| = |A| + |B| − |A∩B|`  
        где:
        - `|A∪B|` — количество страниц по запросу A ИЛИ B,
        - `|A|`, `|B|` — количество страниц по каждому запросу,
        - `|A∩B|` — количество страниц по запросу A И B.

   ---

   ## Типы задач и примеры решений

   ### 1. Запрос из одного слова
   **Задача**:  
   По запросу `Крейсер | Линкор` найдено 3700 страниц, `Крейсер & Линкор` — 400, `Линкор` — 1800. Найти количество страниц по запросу `Крейсер`.

   **Решение**:  
   Используем формулу включений-исключений:  
   `|Крейсер∪Линкор| = |Крейсер| + |Линкор| − |Крейсер∩Линкор|`  
   Подставляем значения:  
   `3700 = |Крейсер| + 1800 − 400 ⟹ |Крейсер| = 2300`  

   **Ответ**: 2300 тысяч страниц.

   ---

   ### 2. Запрос из двух слов
   **Задача**:  
   По запросу `Пушкин` найдено 3500 страниц, `Лермонтов` — 2000, `Пушкин | Лермонтов` — 4500. Найти количество страниц по запросу `Пушкин & Лермонтов`.

   **Решение**:  
   Формула включений-исключений:  
   `|Пушкин∪Лермонтов| = |Пушкин| + |Лермонтов| − |Пушкин∩Лермонтов|`  
   Подставляем значения:  
   `4500 = 3500 + 2000 − |Пушкин∩Лермонтов| ⟹ |Пушкин∩Лермонтов| = 1000`  

   **Ответ**: 1000 тысяч страниц.

   ---

   ### 3. Запрос из трёх слов
   **Задача**:  
   По запросам `Финляндия & Швеция` найдено 160 страниц, `Финляндия & Норвегия` — 255, `Финляндия & (Швеция | Норвегия)` — 360. Найти количество страниц по запросу `Финляндия & Швеция & Норвегия`.

   **Решение**:  
   Используем формулу для трёх множеств:  
   `|Финляндия∩(Швеция∪Норвегия)| = |Финляндия∩Швеция| + |Финляндия∩Норвегия| − |Финляндия∩Швеция∩Норвегия|`  
   Подставляем значения:  
   `360 = 160 + 255 − |Финляндия∩Швеция∩Норвегия| ⟹ |Финляндия∩Швеция∩Норвегия| = 55`  

   **Ответ**: 55 тысяч страниц.

   ---

   ## Частые ошибки
   1. **Путаница между И и ИЛИ**:
      - `И` уменьшает количество страниц (только общие),
      - `ИЛИ` увеличивает (все страницы с любым из слов).
   2. **Неправильный учёт пересечений**:
      - Если в задаче не указано `|A∩B|`, его нужно найти через формулу.
   3. **Игнорирование тройных пересечений**:
      - В задачах с тремя запросами важно учесть все комбинации.

   ---

   ## Советы по решению
   1. **Рисуйте диаграммы Эйлера-Венна** для визуализации пересечений.
   2. **Проверяйте единицы измерения**: Все данные должны быть в одинаковых единицах (например, тысячи страниц).
   3. **Тренируйтесь на примерах**: Чем больше задач решите, тем лучше запомните формулы.
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 9",
                        image = R.drawable.theory1,
                        content = """ 
   # Тема: Поиск путей в графах между городами с учётом условий (прохождение через пункт или его исключение)

   ## Основные понятия
   - **Граф (схема)** — набор вершин (городов) и рёбер (дорог, связей) между ними.
   - **Путь** — последовательность вершин, в которых каждая пара соседних соединена рёбром.
   - **Простой путь** — путь, который не проходит через одну и ту же вершину более одного раза (исключая, если нужно, начальную/конечную).
   - **Количество путей** — число различных простых путей из первой вершины в целевую.

   ---

   ## Типы задач и примеры решений

   ### 1. Поиск всех путей из города X в город Y
   **Задача**:  
   Перечислить (или посчитать), сколькими разными способами можно добраться из X в Y, не повторяя города.

   **Что делать**:
   1. **Выписать все смежности**:  
      Для каждой вершины запишите, куда из неё можно попасть (смежные вершины).
   2. **Начать перебор**:
      - Старт из X.
      - Для каждой возможной соседней вершины продлить путь, пока не придём в Y.
      - При продлении не возвращаться в уже посещённые вершины.
   3. **Перечислить/посчитать найденные простые пути**.

   **Пример**:  
   На схеме дорог города A, B, C, D, E, F (стрелки указывают направление движения).  
   Сколько существует различных путей из A в F?
   
   ![roads](https://png.pngtree.com/png-clipart/20210129/ourlarge/pngtree-animal-insect-little-bee-png-image_2844405.jpg)

   **Решение**:  
   Количество путей до города X = сумма путей из всех городов, ведущих в X.  
   Посчитаем последовательно:  
   - `A = 1` (старт)  
   - `B = A = 1`  
   - `C = A = 1`  
   - `D = B = 1`  
   - `E = C + B = 2`  
   - `F = D + E = 1 + 2 = 3`  

   **Ответ**: 3.

   ---

   ### 2. Поиск путей, проходящих или не проходящих через заданный город X
   **Формулировки**:
   1. **Обязательный промежуточный пункт**:  
      Сколько путей из A в Z, которые обязательно посещают X хотя бы один раз?
   2. **Исключающий пункт**:  
      Сколько путей из A в Z, не заходя в X?

   **Что делать**:
   1. **Для обязательного пункта X**:
      - Разбейте задачу на два этапа: `A→X` и `X→Z`.
      - Посчитайте пути `A→X` и `X→Z` (не повторяя вершины).
      - Умножьте результаты: `Количество путей A→X × X→Z`.

   2. **Для исключающего пункта X**:
      - Удалите вершину X и связанные рёбра из графа.
      - Посчитайте пути `A→Z` в оставшемся графе.

   **Пример**:  
   Сколько путей из A в F проходят через C?
   
   ![roads](drawable://theory1)

   **Решение**:  
   1. **Пути A→C**:  
      - `A = 1`  
      - `B = A = 1`  
      - `C = A = 1`  

   2. **Пути C→F** (C как старт):  
      - `C = 1`  
      - `E = C = 1`  
      - `F = E = 1`  

   **Ответ**: `1 × 1 = 1`.

   ---

   ## Полезные советы
   - **Выписывайте смежности** в виде списка — это упрощает перебор.
   - **Обход в глубину вручную**: помечайте посещённые вершины.
   - **Для путей через X**: разделяйте задачу на `A→X` и `X→Z`.
   - **Для путей без X**: удалите X из графа и считайте пути в новом графе.
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 10",
                        image = null,
                        content = """ 
   # Сравнение чисел в различных системах счисления. Перевод чисел, поиск наибольшего/наименьшего, сумма и количество цифр

   ## Общая теория: позиционная система счисления

   1. **Основание системы** (base, обозначим `b`) — число различных символов (цифр), используемых для записи чисел.
      - `b = 2` → двоичная (цифры 0, 1)
      - `b = 8` → восьмеричная (0...7)
      - `b = 10` → десятичная (0...9)
      - `b = 16` → шестнадцатеричная (0...9, A...F)

   2. **Позиционная запись числа**:  
      `(d_n d_{n−1} … d_1 d_0)_b  =  d_n b^n + d_{n−1} b^{n−1} + ⋯ + d_1 b^1 + d_0 b^0`.

   3. **Цифры** `d_i` — целые от `0` до `b − 1`. В шестнадцатеричной: `A = 10`, `B = 11`, ..., `F = 15`.

   ---

   ## Типы задач и примеры решений

   ### 1. Перевод чисел из одной системы счисления в другую

   **Основные правила**:
   - **В десятичную систему**:  
     `a_n ⋅ b^n + a_{n−1} ⋅ b^{n−1} + ... + a_0 ⋅ b^0`,  
     где `a_i` — цифры числа, `b` — основание системы.
   - **Из десятичной в другую систему**:  
     Делим число на основание новой системы и записываем остатки в обратном порядке.

   **Пример 1**:  
   Перевести число `1011_2` в десятичную систему.  
   **Решение**:  
   `1 ⋅ 2^3 + 0 ⋅ 2^2 + 1 ⋅ 2^1 + 1 ⋅ 2^0 = 8 + 0 + 2 + 1 = 11_{10}`.  
   **Ответ**: `11`.

   **Пример 2**:  
   Перевести число `25_{10}` в двоичную систему.  
   **Решение**:  
        25 ÷ 2 = 12 (остаток 1)
        12 ÷ 2 = 6 (остаток 0)
        6 ÷ 2 = 3 (остаток 0)
        3 ÷ 2 = 1 (остаток 1)
        1 ÷ 2 = 0 (остаток 1)
   **Ответ**: `11001_2`.

   ---

   ### 2. Поиск наибольшего/наименьшего числа

   **Стратегия**:
   - Перевести все числа в десятичную систему и сравнить.
   - Или сравнивать по разрядам, если основания систем известны.

   **Пример**:  
   Какое число наибольшее: `1011_2`, `17_8`, `1F_{16}`?  
   **Решение**:  
   - `1011_2 = 11_{10}`  
   - `17_8 = 1⋅8^1 + 7⋅8^0 = 15_{10}`  
   - `1F_{16} = 1⋅16^1 + 15⋅16^0 = 31_{10}`  
   **Ответ**: `1F_{16}`.

   ---

   ### 3. Сумма и количество цифр в записи числа

   **Правила**:
   - **Количество цифр**: Зависит от основания системы. Например, в двоичной системе цифры — 0 и 1.
   - **Сумма цифр**: Сложить все цифры числа в исходной системе.

   **Пример 1**:  
   Сколько цифр в числе `1A7_{16}`?  
   **Ответ**: `3`.

   **Пример 2**:  
   Найти сумму цифр числа `123_4`.  
   **Решение**:  
   `1 + 2 + 3 = 6`.  
   **Ответ**: `6`.

   ---

   ## Итоговые рекомендации

   - Всегда приводите числа к десятичной системе для сравнения.
   - Используйте перевод через степени для `b → 10` и деление для `10 → b`.
   - При работе с суммой/количеством цифр используйте запись в исходной системе.
   - Проверяйте порядок остатков при переводе из десятичной системы.
                        """.trimIndent(),
                        isRead = false
                    ),

                    TheoryEntity(
                        title = "Задание 11",
                        image = null,
                        content = """ 
   # Использование поиска в операционной системе и текстовом редакторе

   ## Навыки и задачи
   **Проверяемые умения**:
   - Поиск файлов по названию, содержимому или параметрам (дата, размер)
   - Работа с архивами (распаковка)
   - Анализ текста в файлах для поиска информации

   ---

   ## Инструменты и приёмы

   ### В операционных системах
   | Задача                     | Windows (Проводник)                          | macOS (Finder)                          | Linux (консоль)                     |
   |----------------------------|----------------------------------------------|-----------------------------------------|-------------------------------------|
   | **Поиск по имени/расширению** | Ввести `*.txt` или `имя*.doc` в строке поиска | `Cmd+F` → вкладка «Имя»                 | `find . -name "*.txt"`             |
   | **Поиск по содержимому**      | Фильтр «Содержит» в строке поиска            | `Cmd+F` → вкладка «Содержимое»          | `grep -R "Мармеладов" .`           |
   | **Фильтрация по дате/размеру** | Панель «Дата изменения» / «Размер»          | Параметры поиска                        | `find . -mtime -7` или `-size +1M` |
   | **Поиск в Zip/Tar**           | Распаковать архив → искать в содержимом      | —                                       | `grep -R "ключ" <(tar -xOzf a.tar.gz)` |

   **Советы**:
   - 🔍 Перед поиском распакуйте архив с текстами.
   - 📂 Работайте с самой верхней папкой, чтобы включить все вложенные файлы.

   ---

   ### В текстовых редакторах
   | Приём                      | Windows (Notepad/Word)                     | Notepad++ / VS Code / Sublime          |
   |----------------------------|--------------------------------------------|----------------------------------------|
   | **Простой поиск**            | `Ctrl+F`                                  | `Ctrl+F`                               |
   | **Поиск и замена**           | `Ctrl+H`                                  | `Ctrl+H`                               |
   | **Учёт регистра**            | Опция «Учитывать регистр»                 | Чекбокс «Match Case»                   |
   | **Регулярные выражения**     | Нет (в Word — wildcard-поиск)             | Включить «Use Regular Expression»      |
   | **Поиск во всех файлах**     | Недоступно                                | «Find in Files» (выбор папки)          |
   | **Подсветка вхождений**      | Word: «Найти все»                         | Автоподсветка при вводе запроса        |

   ---

   ## Пошаговый алгоритм решения
   1. **Распакуйте архив** (ZIP/RAR) в отдельную папку.
   2. **Откройте проводник/терминал** и перейдите в распакованный каталог.
   3. **Поиск по имени файла** (пример: `Достоевский` → используйте маски `*.txt` или путь `Проза/Достоевский.txt`).
   4. **Поиск по содержимому**:
      - Введите в строке поиска ОС ключевое слово (например, `Мармеладов`).
      - Система покажет файлы и строки с совпадениями.
   5. **Анализ в редакторе**:
      - Откройте найденный файл.
      - Используйте `Ctrl+F` → `Marmeladov` или `Мармеладов`.
   6. **Определите контекст**:
      - Частые шаблоны: `Мармеладов <Имя>` или `<Имя> Мармеладов`.
   7. **Запишите ответ** (пример: имя «Семён»).
                        """.trimIndent(),
                        isRead = false
                    ),
                )
                theoryDao.insertAllTheory(initialData)
            }
        }
    }
}